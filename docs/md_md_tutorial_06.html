<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: Chapter 6: Rendering with LScene and LViews</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Louvre
   &#160;<span id="projectnumber">v1.2.1-2</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Chapter 6: Rendering with LScene and LViews </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In the previous chapter, we explored the challenges of rendering efficiently using <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">Louvre::LPainter</a>. In this chapter, we'll shift our focus to the <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> system.</p>
<p>A single <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> efficiently manages rendering across all outputs by overseeing multiple child and subchild <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> instances. You only need to define the stacking order, position, and size of each view, and <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> automatically optimizes output rendering for you.</p>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> offers various specialized <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> types, and you can even create your own ones. These views cater to various purposes, including layer grouping, texture and surface display, solid color rectangles, and even nested scenes.</p>
<p>Each view can host multiple child views and has a single parent. Rendering order begins with the parent view and proceeds to its children (from bottom to top), adhering to the sequence defined in the children list.</p>
<h2><a class="anchor" id="autotoc_md175"></a>
Layers</h2>
<p>First, let's establish the structure of our scene. We will create five layers as follows:</p>
<ol type="1">
<li><b>Background Layer</b>: This layer will host views that should always remain behind everything else, such as our wallpaper.</li>
<li><b>Surfaces Layer</b>: Typically, this is where all client surfaces will reside.</li>
<li><b>Overlay Layer</b>: Here, we'll position overlay UI elements, like a topbar.</li>
<li><b>Fullscreen Layer</b>: Toplevel surfaces in fullscreen mode will be displayed here.</li>
<li><b>Cursor Layer</b>: Here, we'll display a cursor view if hardware composition is not avaliable and drag &amp; drop icons.</li>
</ol>
<p>To implement this, we'll create our scene and layers within our <code>ECompositor</code> class, ensuring accessibility from any part of our code.</p>
<h3><a class="anchor" id="autotoc_md176"></a>
src/ECompositor.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ECOMPOSITOR_H</span></div>
<div class="line"><span class="preprocessor">#define ECOMPOSITOR_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LScene.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSceneView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LLayerView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTextureView.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ECompositor : <span class="keyword">public</span> LCompositor</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ECompositor();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initialized() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Virtual constructors</span></div>
<div class="line">    LOutput *createOutputRequest(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Scene and layers</span></div>
<div class="line">    LScene scene;</div>
<div class="line">    LLayerView backgroundLayer  { scene.mainView() };</div>
<div class="line">    LLayerView surfacesLayer    { scene.mainView() };</div>
<div class="line">    LLayerView overlayLayer     { scene.mainView() };</div>
<div class="line">    LLayerView fullscreenLayer  { scene.mainView() };</div>
<div class="line">    LLayerView cursorLayer      { scene.mainView() };</div>
<div class="line">    LTextureView softwareCursor { <span class="keyword">nullptr</span>, &amp;cursorLayer };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ECOMPOSITOR_H</span></div>
<div class="ttc" id="anamespace_louvre_html"><div class="ttname"><a href="namespace_louvre.html">Louvre</a></div><div class="ttdoc">Namespaces.</div></div>
</div><!-- fragment --><p>Here, we are defining our layers using <a class="el" href="class_louvre_1_1_l_layer_view.html" title="Container of views.">Louvre::LLayerView</a> and also creating an <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a> that we'll use to display the cursor when hardware composition is not available.</p>
<p>We add the layers to <a class="el" href="class_louvre_1_1_l_scene.html#a3e286163c4778f03be138bba312e37ad" title="Retrieve the main view of the scene.">Louvre::LScene::mainView()</a> in the order in which they will be rendered, from bottom to top, and initialize the <code>softwareCursor</code> view with a <code>nullptr</code> texture, automatically hiding it.</p>
<blockquote class="doxtable">
<p>Each view type has an <a class="el" href="class_louvre_1_1_l_view.html#a6ca65b2aa72ef4be01b3b41e4f358bce" title="Check if the view should be rendered, taking into consideration several conditions.">Louvre::LView::mapped()</a> property that the scene uses to determine whether it meets the criteria for being drawn. For instance, in the case of <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a>, having a non-nullptr texture is one of these conditions. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md177"></a>
src/ECompositor.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LKeyboard.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"> </div>
<div class="line">ECompositor::ECompositor()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Set black as the scene clear color</span></div>
<div class="line">    scene.mainView()-&gt;setClearColor(0.f, 0.f, 0.f, 1.f);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// This allow us to define a custom size to an LTextureView</span></div>
<div class="line">    softwareCursor.enableDstSize(<span class="keyword">true</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>Furthermore, we set the background color for the <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> to black and finally, we call <code>softwareCursor.enableDstSize(true)</code> which allow us to specify a size to the <code>softwareCursor</code> view that is independent from its texture and buffer scale.</p>
<h2><a class="anchor" id="autotoc_md178"></a>
Integrating LScene with LOutput</h2>
<p>To enable our scene to render into our outputs, we need to "plug it" into them like this:</p>
<h3><a class="anchor" id="autotoc_md179"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LPainter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTexture.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LOpenGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LLog.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LDNDManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"> </div>
<div class="line">EOutput::EOutput(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : LOutput(params) {}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::initializeGL()</div>
<div class="line">{</div>
<div class="line">    ECompositor *comp { (ECompositor*)compositor() };</div>
<div class="line">    comp-&gt;scene.handleInitializeGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::moveGL()</div>
<div class="line">{</div>
<div class="line">    ECompositor *comp { (ECompositor*)compositor() };</div>
<div class="line">    comp-&gt;scene.handleMoveGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::resizeGL()</div>
<div class="line">{</div>
<div class="line">    ECompositor *comp { (ECompositor*)compositor() };</div>
<div class="line">    comp-&gt;scene.handleResizeGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    ECompositor *comp { (ECompositor*)compositor() };</div>
<div class="line">    comp-&gt;scene.handlePaintGL(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL()</div>
<div class="line">{</div>
<div class="line">    ECompositor *comp { (ECompositor*)compositor() };</div>
<div class="line">    comp-&gt;scene.handleUninitializeGL(<span class="keyword">this</span>);</div>
<div class="line">}</div>
</div><!-- fragment --><p>It's crucial to plug the scene into all these events, as it needs to initialize resources before it can handle <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> events and release resources when an output is uninitialized.</p>
<p>If you recompile and run the compositor, you will only see a black background because we've only added layer views, which are invisible by themselves, and the cursor view doesn't have a texture yet.</p>
<p>You might have also observed that we constantly need to cast <a class="el" href="class_louvre_1_1_l_compositor.html" title="Louvre&#39;s primary class and resource factory.">Louvre::LCompositor</a> into our own <code>ECompositor</code> subclass, which can become cumbersome and verbose over time. To streamline this, let's create a global class called "G" to store quick access to global variables like that, eliminating the need for repetitive casting.</p>
<h3><a class="anchor" id="autotoc_md180"></a>
src/Global.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef G_H</span></div>
<div class="line"><span class="preprocessor">#define G_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ECompositor;</div>
<div class="line"><span class="keyword">class </span>EOutput;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>G</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> ECompositor *compositor()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (ECompositor*)<a class="code" href="class_louvre_1_1_l_compositor.html#a9b5c246d69cf64361971f2d6ef18c4bf">LCompositor::compositor</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> <span class="keyword">inline</span> std::vector&lt;EOutput*&gt; &amp;outputs()</div>
<div class="line">    {</div>
<div class="line">        <span class="keywordflow">return</span> (std::vector&lt;EOutput*&gt;&amp;)<a class="code" href="class_louvre_1_1_l_compositor.html#a9b5c246d69cf64361971f2d6ef18c4bf">LCompositor::compositor</a>()-&gt;<a class="code" href="class_louvre_1_1_l_compositor.html#acbe59b0fc2ef056851b08b27c13ed30a">outputs</a>();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">static</span> LScene *scene();</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// G_H</span></div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html_a9b5c246d69cf64361971f2d6ef18c4bf"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html#a9b5c246d69cf64361971f2d6ef18c4bf">Louvre::LCompositor::compositor</a></div><div class="ttdeci">static LCompositor * compositor()</div><div class="ttdoc">Get the static LCompositor instance.</div><div class="ttdef"><b>Definition:</b> LCompositor.cpp:74</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_compositor_html_acbe59b0fc2ef056851b08b27c13ed30a"><div class="ttname"><a href="class_louvre_1_1_l_compositor.html#acbe59b0fc2ef056851b08b27c13ed30a">Louvre::LCompositor::outputs</a></div><div class="ttdeci">const std::vector&lt; LOutput * &gt; &amp; outputs() const</div><div class="ttdoc">Get a list of all initialized outputs.</div><div class="ttdef"><b>Definition:</b> LCompositor.cpp:483</div></div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md181"></a>
src/Global.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"> </div>
<div class="line">LScene *G::scene()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">return</span> &amp;compositor()-&gt;scene;</div>
<div class="line">}</div>
</div><!-- fragment --><p>Now, we can easily access our compositor and scene from anywhere using <code>G::compositor()</code> and <code>G::scene()</code>, as well as the vector of initialized outputs with <code>G::outputs()</code>. You only need to include the <code>Global.h</code> header, of course.</p>
<h2><a class="anchor" id="autotoc_md182"></a>
Wallpaper</h2>
<p>Let's explore how to display our wallpaper in a more sophisticated manner. This time, we'll ensure the texture covers the output while maintaining its aspect ratio, rather than simply scaling it to the output size like before.</p>
<p>To display the wallpaper, we can use <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a>.</p>
<h3><a class="anchor" id="autotoc_md183"></a>
src/EOutput.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef EOUTPUT_H</span></div>
<div class="line"><span class="preprocessor">#define EOUTPUT_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LOutput.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTextureView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput : <span class="keyword">public</span> LOutput</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    EOutput(<span class="keyword">const</span> <span class="keywordtype">void</span> *params);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> initializeGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> moveGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> resizeGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> paintGL() <span class="keyword">override</span>;</div>
<div class="line">    <span class="keywordtype">void</span> uninitializeGL() <span class="keyword">override</span>;</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> updateWallpaper();</div>
<div class="line">    LTextureView wallpaperView { <span class="keyword">nullptr</span>, &amp;G::compositor()-&gt;backgroundLayer };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EOUTPUT_H</span></div>
</div><!-- fragment --><p>Notice that we've replaced the wallpaper <a class="el" href="class_louvre_1_1_l_texture.html" title="OpenGL texture abstraction.">Louvre::LTexture</a> pointer with an <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a> and added an <code>updateWallpaper()</code> method. Within this method, we will accurately crop and scale our wallpaper each time the output size changes.</p>
<h3><a class="anchor" id="autotoc_md184"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;LPainter.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTexture.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LOpenGL.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LLog.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LDNDManager.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LCursor.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LSeat.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTextureView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line">EOutput::EOutput(<span class="keyword">const</span> <span class="keywordtype">void</span> *params) : LOutput(params)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* Texture views have a default nullptr translucent region, which means they are considered</span></div>
<div class="line"><span class="comment">     * completely translucent by the scene. However, setting an empty LRegion (not nullptr) indicates</span></div>
<div class="line"><span class="comment">     * to the scene that the view is completely opaque. */</span></div>
<div class="line">    <span class="keyword">const</span> LRegion emptyRegion;</div>
<div class="line">    wallpaperView.setTranslucentRegion(&amp;emptyRegion);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::initializeGL()</div>
<div class="line">{</div>
<div class="line">    updateWallpaper();</div>
<div class="line">    G::scene()-&gt;handleInitializeGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::moveGL()</div>
<div class="line">{</div>
<div class="line">    wallpaperView.setPos(pos());</div>
<div class="line">    G::scene()-&gt;handleMoveGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::resizeGL()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> totalWidth { 0 };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">for</span> (EOutput *o : G::outputs())</div>
<div class="line">    {</div>
<div class="line">        o-&gt;setPos(<a class="code" href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">LPoint</a>(totalWidth, 0));</div>
<div class="line">        totalWidth += o-&gt;size().w();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    updateWallpaper();</div>
<div class="line">    G::scene()-&gt;handleResizeGL(<span class="keyword">this</span>);</div>
<div class="line">    repaint();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    G::scene()-&gt;handlePaintGL(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL()</div>
<div class="line">{</div>
<div class="line">    G::scene()-&gt;handleUninitializeGL(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* When a texture used by an LTextureView is destroyed,</span></div>
<div class="line"><span class="comment">     * the view&#39;s texture is automatically set to nullptr. */</span></div>
<div class="line">    <span class="keywordflow">if</span> (wallpaperView.texture())</div>
<div class="line">        <span class="keyword">delete</span> wallpaperView.texture();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::updateWallpaper()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">if</span> (wallpaperView.texture())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">/* If the current wallpaper size is equal to the output size</span></div>
<div class="line"><span class="comment">         * then the output simply changed its scale */</span></div>
<div class="line">        <span class="keywordflow">if</span> (wallpaperView.texture()-&gt;sizeB() == sizeB())</div>
<div class="line">        {</div>
<div class="line">            wallpaperView.setBufferScale(scale());</div>
<div class="line">            wallpaperView.setPos(pos());</div>
<div class="line">            <span class="keywordflow">return</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="keyword">delete</span> wallpaperView.texture();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    LTexture *originalWallpaper {</div>
<div class="line">        LOpenGL::loadTexture(compositor()-&gt;defaultAssetsPath() / <span class="stringliteral">&quot;wallpaper.png&quot;</span>) };</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (!originalWallpaper)</div>
<div class="line">    {</div>
<div class="line">        LLog::error(<span class="stringliteral">&quot;[louvre-example] Failed to load wallpaper.&quot;</span>);</div>
<div class="line">        <span class="keywordflow">return</span>;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;originalSize { originalWallpaper-&gt;sizeB() };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* This section calculates the source wallpaper rect that needs to be copied and scaled to cover the entire output</span></div>
<div class="line"><span class="comment">     * while maintaining the image&#39;s aspect ratio. */</span></div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Source rect within the texture to clip</span></div>
<div class="line">    <a class="code" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a> srcRect { 0 };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Calculate the texture&#39;s width if it were scaled to the output&#39;s height, while preserving the aspect ratio</span></div>
<div class="line">    <span class="keyword">const</span> <a class="code" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> scaledWidth { <a class="code" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>(size().w() * originalSize.h()) / <a class="code" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>(size().h()) };</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// If the scaled width is greater than or equal to the output&#39;s width, we clip the texture&#39;s left and right sides</span></div>
<div class="line">    <span class="keywordflow">if</span> (scaledWidth &gt;= originalSize.w())</div>
<div class="line">    {</div>
<div class="line">        srcRect.setW(originalSize.w());</div>
<div class="line">        srcRect.setH((originalSize.w() * size().h()) / size().w());</div>
<div class="line">        srcRect.setY((originalSize.h() - srcRect.h()) / 2);</div>
<div class="line">    }</div>
<div class="line">    <span class="comment">// Otherwise, we clip the texture&#39;s top and bottom</span></div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        srcRect.setH(originalSize.h());</div>
<div class="line">        srcRect.setW((originalSize.h() * size().w()) / size().h());</div>
<div class="line">        srcRect.setX((originalSize.w() - srcRect.w()) / 2);</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Copy the srcRect of the original wallpaper and scale it to match the output buffer size</span></div>
<div class="line">    wallpaperView.setTexture(originalWallpaper-&gt;copyB(sizeB(), srcRect));</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Set the buffer scale of wallpaperView to match the output scale</span></div>
<div class="line">    wallpaperView.setBufferScale(scale());</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Delete the original wallpaper texture since we are using the scaled copy</span></div>
<div class="line">    <span class="keyword">delete</span> originalWallpaper;</div>
<div class="line">    wallpaperView.setPos(pos());</div>
<div class="line">}</div>
<div class="ttc" id="anamespace_louvre_html_a20b0c262d9ef5d263888e463dfa99638"><div class="ttname"><a href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Louvre::Int32</a></div><div class="ttdeci">int32_t Int32</div><div class="ttdoc">32 bits signed integer</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:210</div></div>
<div class="ttc" id="anamespace_louvre_html_a4df5473974ae0f28f3a4967f296a657b"><div class="ttname"><a href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">Louvre::LSize</a></div><div class="ttdeci">LPoint LSize</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:243</div></div>
<div class="ttc" id="anamespace_louvre_html_a87d38f886e617ced2698fc55afa07637"><div class="ttname"><a href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Louvre::Float32</a></div><div class="ttdeci">float Float32</div><div class="ttdoc">32 bits float</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:234</div></div>
<div class="ttc" id="anamespace_louvre_html_a968dc093fddc639543f84e482dc539e6"><div class="ttname"><a href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">Louvre::LRect</a></div><div class="ttdeci">LRectTemplate&lt; Int32, Float32 &gt; LRect</div><div class="ttdoc">4D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:252</div></div>
<div class="ttc" id="anamespace_louvre_html_af44d6a74e89490a3e257f317082c93ea"><div class="ttname"><a href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">Louvre::LPoint</a></div><div class="ttdeci">LPointTemplate&lt; Int32, Float32 &gt; LPoint</div><div class="ttdoc">2D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:240</div></div>
</div><!-- fragment --><p>This is indeed a lot of information to digest, so let's break it down step by step.</p>
<p>First, in the constructor, we use an empty <a class="el" href="class_louvre_1_1_l_region.html" title="Collection of non-overlapping rectangles.">Louvre::LRegion</a> (not the same as <code>nullptr</code>) to set the <code>wallpaperView</code> translucent region, which means the entire view will be considered opaque. If we were to pass <code>nullptr</code>, the entire view would be translucent, which is the default value. We make it opaque intentionally because otherwise the background would unnecessary be repainted each time the wallpaper is repainted, consuming additional processing power.<br  />
 In <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">Louvre::LOutput::initializeGL()</a> we call our new <code>updateWallpaper()</code> method, where we carry out the following steps:</p>
<ol type="1">
<li>We delete the previous wallpaper if there was any.</li>
<li>We load the original wallpaper image again.</li>
<li>We create a cropped and scaled version using the <a class="el" href="class_louvre_1_1_l_texture.html#a1e0be1580980487ef3305943fca016f7" title="Create a copy of the texture.">Louvre::LTexture::copyB()</a> method to ensure it covers the entire output while maintaining the wallpaper's original aspect ratio.</li>
<li>We update the wallpaper buffer scale and position.</li>
</ol>
<p>It's important to note that each <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a> has a default buffer scale of 1. Since we are setting the buffer size of the texture to match the output buffer size, we also need to ensure their scales match. This is because <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> internally uses <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">Louvre::LPainter</a> for rendering, and it expects the position and size of each view to be in surface coordinates. If the output is HIDPi and we assign it a scale of 2, while keeping the wallpaper view at a scale of 1, it would appear twice as big. This may sound counterintuitive, but think of it this way, if both the wallpaper and the output have the same scale, then no transformations are required by <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">Louvre::LPainter</a> to render the view on the output.</p>
<p>Alternatively, starting from <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> version 1.2, you can achieve the same cropping effect by specifying a custom source rect for <a class="el" href="class_louvre_1_1_l_texture_view.html" title="View for displaying textures.">Louvre::LTextureView</a> (refer to <a class="el" href="class_louvre_1_1_l_texture_view.html#a64722a3a782e769f69fb93feaf0882ee" title="Sets the source rect of the texture to use.">Louvre::LTextureView::setSrcRect()</a>). However, creating a cropped and scaled version of the texture that fits perfectly on the screen can enhance the compositor's performance, especially in cases where the texture is larger than the screen resolution.</p>
<p>In <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">Louvre::LOutput::moveGL()</a>, we simply set the wallpaper position equal to the output position.</p>
<p>In <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">Louvre::LOutput::resizeGL()</a>, we re-arrange our initialized outputs and call <code>updateWallpaper()</code> again so that it gets resized to match the new output resolution or scale.</p>
<p>Finally, in <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">Louvre::LOutput::uninitializeGL()</a>, we check if the wallpaper view has a texture attached and delete it.</p>
<p>It's worth noting that a texture is not automatically deleted when a view using it is deleted. This is because you can use the same texture in multiple views at a time. However, when a texture that is currently in use by texture views is deleted, these views' textures are automatically set to <code>nullptr</code>, consequently hiding them.</p>
<p>Try recompiling and running the compositor again, and you should see your wallpaper displayed.</p>
<blockquote class="doxtable">
<p>Remember that you need to run <code>meson setup build --wipe</code> each time you add or remove source files. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md185"></a>
Topbar</h2>
<p>Now, let's create a topbar that will serve as the designated space for displaying minimized window thumbnails.<br  />
Instead of opting for a straightforward <a class="el" href="class_louvre_1_1_l_solid_color_view.html" title="View for displaying solid color rects.">Louvre::LSolidColorView</a> to display a solid color rectangle, we're taking a more versatile approach by introducing a custom class called <code>ETopbar</code>.</p>
<p>First, let's define the top bar's height in a macro within the <code>Global.h</code> header for easy access, as we'll be using it in various parts of our code.</p>
<h3><a class="anchor" id="autotoc_md186"></a>
src/Global.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef G_H</span></div>
<div class="line"><span class="preprocessor">#define G_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LCompositor.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#define TOPBAR_HEIGHT 32</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// G_H</span></div>
</div><!-- fragment --><p>I'm using 32, but feel free to adjust it to your preference.</p>
<h3><a class="anchor" id="autotoc_md187"></a>
src/ETopbar.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef ETOPBAR_H</span></div>
<div class="line"><span class="preprocessor">#define ETOPBAR_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LSolidColorView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ETopbar : <span class="keyword">public</span> LObject</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    ETopbar(EOutput *output);</div>
<div class="line">    ~ETopbar();</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">void</span> destroyThumbnails();</div>
<div class="line">    <span class="keywordtype">void</span> copyThumbnailsFromAnotherTopbar();</div>
<div class="line">    <span class="keywordtype">void</span> updateGUI();</div>
<div class="line"> </div>
<div class="line">    EOutput *output;</div>
<div class="line">    LSolidColorView view {</div>
<div class="line">        0.f,                            <span class="comment">// Red</span></div>
<div class="line">        0.f,                            <span class="comment">// Green</span></div>
<div class="line">        0.f,                            <span class="comment">// Blue</span></div>
<div class="line">        0.8f,                           <span class="comment">// Alpha</span></div>
<div class="line">        &amp;G::compositor()-&gt;overlayLayer  <span class="comment">// Parent view</span></div>
<div class="line">    };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// ETOPBAR_H</span></div>
</div><!-- fragment --><p>In this class, we define an <code>EOutput</code> object as a constructor parameter, which we will store in the <code>output</code> variable. This will enable us to precisely adjust the top bar's size and position relative to its associated output when needed (each output will have its own topbar).</p>
<p>Furthermore, we've incorporated a black and semi translucent <a class="el" href="class_louvre_1_1_l_solid_color_view.html" title="View for displaying solid color rects.">Louvre::LSolidColorView</a> to visually represent the top bar within the scene. As the name implies, <a class="el" href="class_louvre_1_1_l_solid_color_view.html" title="View for displaying solid color rects.">Louvre::LSolidColorView</a> is designed for displaying solid color rectangles.</p>
<p>We've also introduced an <code>updateGUI()</code> method, responsible for dynamically managing the top bar's position, size, and ordering child thumbnail elements as necessary.</p>
<p>Finally the <code>destroyThumbnails()</code> and <code>copyThumbnailsFromAnotherTopbar()</code> methods are self explanatory.</p>
<h3><a class="anchor" id="autotoc_md188"></a>
src/ETopbar.cpp</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;ETopbar.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;EOutput.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line">ETopbar::ETopbar(EOutput *output) : output(output) {}</div>
<div class="line"> </div>
<div class="line">ETopbar::~ETopbar()</div>
<div class="line">{</div>
<div class="line">    destroyThumbnails();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ETopbar::destroyThumbnails()</div>
<div class="line">{</div>
<div class="line">    <span class="keywordflow">while</span> (!view.children().empty())</div>
<div class="line">        <span class="keyword">delete</span> view.children().back();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ETopbar::copyThumbnailsFromAnotherTopbar()</div>
<div class="line">{</div>
<div class="line">    updateGUI();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> ETopbar::update()</div>
<div class="line">{</div>
<div class="line">    view.setSize(output-&gt;size().w(), TOPBAR_HEIGHT);</div>
<div class="line">    view.setPos(output-&gt;pos());</div>
<div class="line">    output-&gt;repaint();</div>
<div class="line">}</div>
</div><!-- fragment --><p>In the constructor, we're straightforwardly storing the output pointer.</p>
<p>In <code>destroyThumbnails()</code> and destructor, we destroy the children views of the topbar that represent the thumbnails of minimized surfaces (we will cover that later).</p>
<p>In <code>copyThumbnailsFromAnotherTopbar()</code>, for now, all we do is call <code>updateGUI()</code>. Later, we will see how to copy the thumbnails.</p>
<p>In <code>updateGUI()</code>, we ensure that the top bar's width matches the output's width, and we set its height to <code>TOPBAR_HEIGHT</code>. We also position it at the same coordinates as the output (we will adjust thumbnails later).</p>
<p>Now we only need to create it from its respective output:</p>
<h3><a class="anchor" id="autotoc_md189"></a>
src/EOutput.h</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#ifndef EOUTPUT_H</span></div>
<div class="line"><span class="preprocessor">#define EOUTPUT_H</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &lt;LOutput.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;LTextureView.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ECompositor.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;ETopbar.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;Global.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespace_louvre.html">Louvre</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>ETopbar;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">class </span>EOutput : <span class="keyword">public</span> LOutput</div>
<div class="line">{</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    ETopbar topbar { <span class="keyword">this</span> };</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#endif </span><span class="comment">// EOUTPUT_H</span></div>
</div><!-- fragment --><p>And ensure it is appropriately adjusted whenever the output geometry changes.</p>
<h3><a class="anchor" id="autotoc_md190"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="preprocessor">#include &quot;ETopbar.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::initializeGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    topbar.copyThumbnailsFromAnotherTopbar();</div>
<div class="line">    G::scene()-&gt;handleInitializeGL(<span class="keyword">this</span>);</div>
<div class="line">    </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::moveGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    topbar.updateGUI();</div>
<div class="line">    G::scene()-&gt;handleMoveGL(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::resizeGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    topbar.updateGUI();</div>
<div class="line">    G::scene()-&gt;handleResizeGL(<span class="keyword">this</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::uninitializeGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">    topbar.destroyThumbnails();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
</div><!-- fragment --><p>We also make sure to destroy any thumbnail added to the top bar of surfaces that remain alive after an output is uninitialized.</p>
<p>With these steps in place, you should now be able to admire your elegant black topbar after recompiling and running your compositor.</p>
<p><img src="https://lh3.googleusercontent.com/pw/ADCreHdSqkWstdqyTsfb1kMmhZwZi_uoydlPmxAhwM5IZ4PdHR3H6xdA2Ahyd8yaKAarLmYlbtzjxaoJomO_mbzvdYeAx8nb9DA-hDvC0ULoyKmyrJh4wII=w2400" alt="" class="inline"/></p>
<h2><a class="anchor" id="autotoc_md191"></a>
Rendering the Cursor</h2>
<p>We have yet to address the scenario in which hardware cursor compositing is not supported. To display the cursor in such cases, we can set the <code>softwareCursor</code> texture to <a class="el" href="class_louvre_1_1_l_cursor.html#a52e4e47bca65c2c757633d2b2d44cab1" title="Get the current cursor texture.">Louvre::LCursor::texture()</a> and its size and position to <a class="el" href="class_louvre_1_1_l_cursor.html#abbe7dd7c81791c49ac9c4a2e73bb4271" title="Get the cursor rect on the screen.">Louvre::LCursor::rect()</a>.</p>
<p>As cursor hardware composition can vary across different outputs, we should enable or disable the <code>softwareCursor</code> view within each <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">Louvre::LOutput::paintGL()</a> event, just before invoking <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a>, like this:</p>
<h3><a class="anchor" id="autotoc_md192"></a>
src/EOutput.cpp</h3>
<div class="fragment"><div class="line"><span class="comment">//...</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> EOutput::paintGL()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Check if hw cursor is supported</span></div>
<div class="line">    <span class="keywordflow">if</span> (cursor()-&gt;hasHardwareSupport(<span class="keyword">this</span>))</div>
<div class="line">        G::compositor()-&gt;softwareCursor.setTexture(<span class="keyword">nullptr</span>);</div>
<div class="line">    <span class="keywordflow">else</span></div>
<div class="line">    {</div>
<div class="line">        G::compositor()-&gt;softwareCursor.setTexture(cursor()-&gt;texture());</div>
<div class="line">        G::compositor()-&gt;softwareCursor.setPos(cursor()-&gt;rect().pos());</div>
<div class="line">        G::compositor()-&gt;softwareCursor.setDstSize(cursor()-&gt;rect().size());</div>
<div class="line">        G::compositor()-&gt;softwareCursor.setVisible(cursor()-&gt;visible());</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    G::scene()-&gt;handlePaintGL(<span class="keyword">this</span>);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line"><span class="comment">//...</span></div>
</div><!-- fragment --><p>We perform a check to determine whether the output supports hardware cursor compositing. If it does, we hide the <code>softwareCursor</code> view by setting its texture to <code>nullptr</code>. Otherwise, we adjust its texture, position, size, and visibility to match those of <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">Louvre::LCursor</a>.</p>
<h2><a class="anchor" id="autotoc_md193"></a>
LScene Internal Behaviour</h2>
<p>You've probably noticed that every time a parameter of a view is changed, it doesn't necessarily mean that the view is immediately rendered. You can modify the parameters as many times as you want, but it's only when <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a> is called that the scene analyzes all the views and exclusively paints the parts that have changed. This means that if, for example, you assign the same parameter repeatedly with the same value to a view, the screen might never be repainted, and the rendering thread might remain blocked (because there is nothing new to render). On the other hand, whenever you change a parameter, the views call <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">Louvre::LOutput::repaint()</a> on all the outputs they are currently visible, which eventually invokes <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a>.</p>
<h2><a class="anchor" id="autotoc_md194"></a>
Performing Advanced Rendering</h2>
<p>A question you might also be asking yourself is why it is necessary to manually plug all the scene <code>handle..GL</code> methods in each event, and why <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> doesn't do it automatically for you. The reason for this is that <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> specializes only in 2D rendering, but there may be occasions when you want to perform 3D rendering or add sophisticated effects/animations. In those cases, you can perform rendering using your own methods before or after calling <a class="el" href="class_louvre_1_1_l_scene.html#a980646107c925c155e58646741a0fa8c" title="Handle the OpenGL painting for an LOutput.">Louvre::LScene::handlePaintGL()</a>, or even not calling it at all.</p>
<p>That's an alternative. If you want to exclusively use the scene and view system, you have also the option to create your own customized views and even build a complete toolkit around them. To do so, you'd need to create your own subclasses of <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> and override various of its virtual methods, such as <a class="el" href="class_louvre_1_1_l_view.html#af495f50b6512f70702f5ae53b94bf145" title="Request to paint a region of the view to the current framebuffer.">Louvre::LView::paintEvent()</a>, which is invoked by <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">Louvre::LScene</a> or <a class="el" href="class_louvre_1_1_l_scene_view.html" title="View for rendering other views.">Louvre::LSceneView</a> when they request the view to repaint one of its regions.</p>
<p>For more information on creating your own views, refer to the <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">Louvre::LView</a> documentation.</p>
<h2><a class="anchor" id="autotoc_md195"></a>
Surfaces</h2>
<p>Rendering surfaces introduces a bit more complexity as we must keep track of when they are created and monitor changes in their stacking order. In the upcoming chapter, we will delve deeply into surfaces, exploring how to render them using <a class="el" href="class_louvre_1_1_l_surface_view.html" title="View for displaying surfaces.">Louvre::LSurfaceView</a>, and handle specific events, such as detecting when they are minimized. See you there!</p>
<p><a href="md_md_tutorial_05.html">◀ Chapter 5: Rendering with LPainter</a> || <a href="md_md_tutorial_07.html">Chapter 7: Surfaces ▶</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>