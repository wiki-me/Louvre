<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Louvre: LOutput Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="Logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Louvre
   &#160;<span id="projectnumber">v1.2.1-2</span>
   </div>
   <div id="projectbrief">C++ library for Wayland compositors</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespace_louvre.html">Louvre</a></li><li class="navelem"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="class_louvre_1_1_l_output-members.html">List of all members</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">LOutput Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_l_output_8h_source.html">LOutput.h</a>&gt;</code></p>

<p>A display rendering interface.  
 <a href="class_louvre_1_1_l_output.html#details">More...</a></p>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A display rendering interface. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class is responsible for rendering content to a display. It is typically associated with a computer screen, but could also represent a window within an X11 or Wayland desktop, depending on the selected graphic backend.</p>
<center><img src="https://lh3.googleusercontent.com/4lV1LTHBmO-eFywBrL4UhYIRcQbV5bjGB_17FdWFCzjGvnklxwBnXz5hQKOrkRCOegsn6PjnYZNCWk1SjFjwh9t8olEzr3Uwzd3saEt8EKRbbqX0n1f5R7q6r6V9u1t0PUk7BB0teA" alt="" height="250px" class="inline"/></center><h1><a class="anchor" id="Access"></a>
Access</h1>
<p>The graphic backend is responsible for creating each <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> making a request to the compositor through <a class="el" href="class_louvre_1_1_l_compositor.html#a89b1ee3a2dc82fb496346c3b8ec581eb" title="Virtual constructor for creating LOutput instances when needed by the graphic backend.">LCompositor::createOutputRequest()</a>.<br  />
You can override that virtual constructor to use your own <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> subclasses.<br  />
The <a class="el" href="class_louvre_1_1_l_seat.html" title="Group of input and output devices.">LSeat</a> class grants access to all outputs created by the graphic backend through <a class="el" href="class_louvre_1_1_l_seat.html#acbe59b0fc2ef056851b08b27c13ed30a" title="Vector of available outputs.">LSeat::outputs()</a> and it also notifies you of hotplugging events (e.g. when connecting or disconnecting a display through an HDMI port).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_seat.html#ade85a580ee6b9aa3aaead45f948d2e82" title="New available output.">LSeat::outputPlugged()</a> and <a class="el" href="class_louvre_1_1_l_seat.html#aff161f8b1d3c715362778773b4b612c6" title="Disconnected output.">LSeat::outputUnplugged()</a></dd></dl>
<h1><a class="anchor" id="Initialization"></a>
Initialization</h1>
<p>By default, outputs are inactive and cannot be rendered on. To activate an output, use the <a class="el" href="class_louvre_1_1_l_compositor.html#a0b328b0723a35d00bbaff5aec6b9e9e0" title="Initializes the specified output.">LCompositor::addOutput()</a> method. This initializes its rendering thread, graphic context, and triggers the <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">initializeGL()</a> event. Subsequently, whenever the <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> method is called, the rendering thread unblocks, and the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event is invoked, allowing you perform painting operations.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> by default initializes all available outputs once the compositor is started within the <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a> event.</dd></dl>
<h1><a class="anchor" id="Uninitialization"></a>
Uninitialization</h1>
<p>If you no longer wish to use an output, call the <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">LCompositor::removeOutput()</a> method to remove it from the compositor. This will only uninitialize it, making it possible to re-initialize it later.<br  />
An <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> is no longer available when its virtual destructor is invoked (<a class="el" href="class_louvre_1_1_l_compositor.html#abba88891ebb04dd3e5b992eb89e13ed3" title="Virtual destructor for the LOutput class.">LCompositor::destroyOutputRequest()</a>).</p>
<h1><a class="anchor" id="Rendering"></a>
Rendering</h1>
<p>Painting operations must exclusively take place within a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event, as rendering elsewhere won't be visible on the screen.<br  />
When you call <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a>, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> unlocks the output rendering thread and invokes <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> just once, regardless of the number of <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> calls during a frame.<br  />
To unlock the rendering thread again, you must call <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> within or after the last <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.<br  />
The graphic backend is in charge of triggering the <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">initializeGL()</a>, <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">moveGL()</a>, <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a>, <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a>, and <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">uninitializeGL()</a> events, so you must avoid calling them directly.</p>
<h1><a class="anchor" id="Context"></a>
Context</h1>
<p>Each output has its own OpenGL context and its own instance of <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a>, which can be accessed with the <a class="el" href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b" title="Get access to the associated LPainter.">painter()</a> method.<br  />
You can use the functions provided by <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a> to render colored rects or textures, or use the native OpenGL functions and your own shaders/programs if you wish.</p>
<dl class="section note"><dt>Note</dt><dd>Consider leveraging the <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">LView</a> classes for rendering, as they automatically calculate and repaint only the portions of an output that require updates. This can significantly enhance the performance of your compositor.</dd></dl>
<h1><a class="anchor" id="Modes"></a>
Modes</h1>
<p>Each <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> can have multiple modes. An <a class="el" href="class_louvre_1_1_l_output_mode.html" title="Output resolution and refresh rate.">LOutputMode</a> contains information about the resolution and refresh rate that the output can operate at.<br  />
You can access the modes of an output with <a class="el" href="class_louvre_1_1_l_output.html#a9ac403f8d9086b7b95588c0fd6284962" title="Vector of available modes.">modes()</a> and set the desired one with <a class="el" href="class_louvre_1_1_l_output.html#a125f832b1a5e470d494a0b3d1edbda2e" title="Set the output mode.">setMode()</a>.<br  />
Outputs by default use the <a class="el" href="class_louvre_1_1_l_output.html#ab22d0dc29c25b8e272daa2818dd81668" title="Get the preferred mode.">preferredMode()</a>, which typically has the highest refresh rate and resolution.<br  />
If you change an output's mode or scale while it's initialized, the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is triggered.</p>
<h1><a class="anchor" id="Arrangement"></a>
Arrangement</h1>
<p>Outputs, like surfaces, have a position and dimensions that allow them to be logically organized in a similar way to how a system settings panel does.<br  />
You can adjust the position of an output using the <a class="el" href="class_louvre_1_1_l_output.html#abd9b75c5594e4fa1e61839aa211f4740" title="Set the position of the output.">setPos()</a> method, which will, in turn, trigger the <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">moveGL()</a> event when the position changes.</p>
<center><img src="https://lh3.googleusercontent.com/VOWUX4iiqYMF_bIrBP3xMyaiydv_e_ZKznCIJlRLaEA0CtBLMuU4h41R3D4Xm-7krk8jFGZrQGb_SS7hlIFUY9E5dVbQqs0Q3NIBXvRFrGs_cukqOmbCv1ExN9fG3BDdj4Yz45xIkQ=w2400" alt="" height="350px" class="inline"/></center><dl class="section note"><dt>Note</dt><dd>To enable <a class="el" href="class_louvre_1_1_l_cursor.html" title="Utility class for rendering cursors.">LCursor</a> to transition across different LOutputs, ensure that the outputs are closely arranged side by side.</dd></dl>
<h1><a class="anchor" id="Scaling"></a>
Scaling</h1>
<p>Many screens nowadays are HiDPI, so it is commonly required to apply a scaling factor to prevent content from appearing tiny on the screen. By default, all screens in <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> have a scaling factor of 1, meaning no scaling is applied. To assign a scale to a screen, you can use <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a>, which modifies the size returned by <a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528" title="Get the output size in compositor coordinates.">size()</a> and <a class="el" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271" title="Get the output rect.">rect()</a>.</p>
<p>In <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a>, you typically work with two coordinate systems: <em><b>buffer coordinates</b></em> and <em><b>surface coordinates</b></em>.</p>
<p>In buffer coordinates, the scale is not taken into account, and the dimensions always have maximum granularity. For example, if a screen has a resolution of 2000x1000px, its size in buffer coordinates would be the same: 2000x1000px, which is returned by <a class="el" href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc" title="Get the output size in buffer coordinates.">sizeB()</a>. However, the global coordinate space of the compositor uses surface coordinates, which is equal to the size in buffer coordinates divided by the applied scale. Therefore, if a factor of 2 is used, the size in surface coordinates would be 1000x500, which is returned by <a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528" title="Get the output size in compositor coordinates.">size()</a>.</p>
<p>When arranging displays, both the position and size of the outputs should be considered in surface coordinates.</p>
<p>Let's look at an example to make these concepts clearer:</p>
<p>Let's assume you have two displays, one with a resolution of 1000x500px and another with 2000x1000px (double the resolution), but both with a physical size of 22''. This means that the space occupied by 1px on the blue screen accommodates 4px on the pink screen.</p>
<p>If you were to see it in person, side by side they would look like this:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV87QBEaAMVfuF92jfv0HRQrEgc0PMKgx9N29Wb6dDbF9cHLpCr7qSDUowUFnBXFHJxg4F9c7v7EcxxTSnpSzkEqLvCB7CxlnUYJmG1JsNspSHRq3zZE=w2400" alt="" class="inline"/></center><p>If you assign the same scaling factor of 1 to both screens, their sizes in surface coordinates would be the same as in buffer coordinates. Therefore, the global coordinate space of the compositor would look like this:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86CZvhAIc-yONr5BQe6ABGxfcuSVajo1jobAWL5C6tMdJO8BXjsbMbZk7r7rEZ9-ZsYmr3LsIdBSKkb3npEYoCIG1OD0iZKUoCDFVoqMG4avt06Vhs=w2400" alt="" class="inline"/></center><p>And if you were to see your screens in real life, it would look like the following. In the pink screen, everything would appear tiny, half the size of the blue screen. And as you can see, if you were to drag an application window from one screen to another, it would look somewhat odd.</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV84F3o3dewpcSRttqMHPjKO2YYUqSJ299tj760KcT6KRd0s7uf_bXtKQfwy5CFeXqPoxynuu2UmtkEOodg1l7DjZHoXohjXdpGIth9S50mKGdsHqfPw=w2400" alt="" class="inline"/></center><p>Now, let's imagine that you assign a scaling factor of 2 to the pink screen. In this case, the global coordinate space of the compositor would look as follows:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86j52vqCYAxcm94frzQHzeI47idYlb-tggnlbwcVsZZwXIkr9M4tyhKPMDLfmtjOYqHWS9jnCiXojuusl8EKyv3OIn8KQX6biHr0hQeLxH7m04VaTc=w2400" alt="" class="inline"/></center><p>And therefore, if you were to see it in real life now, it would appear consistently.</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV87mN6ufD6PY9Rt8fjl3B84ii627PdOYwJx9vmeA72EeT_cpr8Q01IdoiBknoPI6fonVJWRCW34VZNKVKCsNIERY70Gvqkl7eH0R2vr3gBrEtuMNps0=w2400" alt="" class="inline"/></center><p>Therefore, in summary, the size of a screen in surface coordinates is determined by dividing its buffer size by the applied scale.</p>
<h2><a class="anchor" id="autotoc_md16"></a>
Fractional Scaling</h2>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> also supports fractional scaling, albeit with some differences compared to integer scaling. For instance, if you assign a scale of 1.5 using <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a> to the pink screen, the resulting applied scale (obtained with <a class="el" href="class_louvre_1_1_l_output.html#a9b81bd5b3d166c724e07edb5255a63bf" title="Retrieve the current output scale factor.">scale()</a>) will be ceil(1.5) = 2. However, the buffer dimensions of the screen will simulate being 2/1.5 times larger than its current mode (rounded), resulting in 2668 x 1334 for this case. Consequently, its size in surface coordinates would be 2668 x 1334 divided by 2. As a result, the compositor coordinate space would appear as follows:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV86R-d2uzDybJ-FLWL5PzbShg33f2_OJX9mQME8DkVI5y6O3eDT18UBRgwY8UScaApeoqU4ePq3BwbDNmW5Z-eW0dukpvdQfmarUbOVEbN_GmYU3MqE=w2400" alt="" class="inline"/></center><p>This creates the illusion of rendering on a larger screen, the result of which is actually scaled to the real size, allowing for the desired scaling effect. Rendering using fractional scales, however, can introduce undesired visual effects like aliasing, especially noticeable when moving elements with textures containing fine details. For this reason, <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> offers the option to render using oversampling, where all the screen content is rendered in a larger buffer, and then that rendered buffer is scaled down to the screen framebuffer. This method almost completely eliminates aliasing but has the disadvantage of consuming more computational power, potentially decreasing performance. Without oversampling the content is directly rendered on the screen, making it efficient but retaining aliasing artifacts. <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> allows you to toggle oversampling on and off instantly at any time using <a class="el" href="class_louvre_1_1_l_output.html#a44cc14aa351b8cda936faedcfdae8b29" title="Enable or disable oversampling for fractional scales.">enableFractionalOversampling()</a>. For example, you could enable it when displaying a desktop with floating windows and disable it when displaying a fullscreen window.</p>
<dl class="section note"><dt>Note</dt><dd>Oversampling is not required and is always disabled when using non-fractional scales. Therefore, as a recommendation, if your monitor supports multiple modes with various resolutions, it is preferable to select one of those modes instead of using fractional scaling.</dd></dl>
<p>Clients supporting the <a href="https://wayland.app/protocols/fractional-scale-v1">fractional scaling protocol</a> are instructed to scale their buffers directly to the fractional scale. On the other hand, clients lacking support for the protocol are advised to use ceil(fractional scale), ensuring a consistently high-detail appearance.</p>
<h1><a class="anchor" id="Transforms"></a>
Transforms</h1>
<p><a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> also supports applying transforms to outputs with <a class="el" href="class_louvre_1_1_l_output.html#a5f46e1d3500815df2b14c9c7e1035e5b" title="Set the framebuffer transformation.">setTransform()</a>. Let's imagine that you physically rotate the pink monitor 90° clockwise while maintaining the same normal transform on both. What you would see is the following:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV85bV4h-OcbW1DozgUCQp4PbMoWOd2E2MNRQveEhw5r2p_mjnVRLbziTJ-egMu9D0eSIbMyLNmXECbupfa1gmQZMAidIS1pT5ahbeoL6hcsa6O3QlYc=w2400" alt="" class="inline"/></center><p>Given that you rotated the screen 90° clockwise, it is necessary to apply a transform that rotates the screen 90° counter-clockwise (<a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36a93defc796ebad74fa4183044984bdb0b" title="Rotate 90 degrees counter-clockwise.">Louvre::LFramebuffer::Rotated90</a>). If you apply this to the pink screen, then you would see the following:</p>
<center><img src="https://lh3.googleusercontent.com/pw/ABLVV84Tm3VGwuNHqbAumAVrzZVgBtKSOo24y8PDk5Y47hIlLmO7uSzIMLeE0f9y-5DOQh1nOI9-qz48c_fnlgkM3CILC-GFB2qttGaE671Xke_jcF6DlVY=w2400" alt="" class="inline"/></center><p>Note that when applying a transformation containing a 90° or 270° rotation to an output, the components of <a class="el" href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc" title="Get the output size in buffer coordinates.">sizeB()</a>, <a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528" title="Get the output size in compositor coordinates.">size()</a> and <code><a class="el" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271" title="Get the output rect.">rect()</a>.<a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528" title="Get the output size in compositor coordinates.">size()</a></code> are swapped (their width becomes the height, and the height becomes the width). The global coordinate space of the compositor is structured in such a way that you can continue rendering in the same manner as if the screens were in their normal transform state. Therefore, there's no need to worry about rotating or flipping the elements you draw. </p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a> </td></tr>
<tr class="memdesc:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of possible states for an <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>.  <a href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">More...</a><br /></td></tr>
<tr class="separator:a5d74787dedbc4e11c1ab15bf487e61f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf3ae70a3f91b9f2d855904572dcbed8"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a> </td></tr>
<tr class="memdesc:acf3ae70a3f91b9f2d855904572dcbed8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration describing the subpixel geometry.  <a href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">More...</a><br /></td></tr>
<tr class="separator:acf3ae70a3f91b9f2d855904572dcbed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac0e3199d5e20da15aaa1f7f1abb99bfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac0e3199d5e20da15aaa1f7f1abb99bfe">LOutput</a> (const void *params)</td></tr>
<tr class="memdesc:ac0e3199d5e20da15aaa1f7f1abb99bfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class.  <a href="class_louvre_1_1_l_output.html#ac0e3199d5e20da15aaa1f7f1abb99bfe">More...</a><br /></td></tr>
<tr class="separator:ac0e3199d5e20da15aaa1f7f1abb99bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad154579ae13924ffd51510a3712c5d55"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad154579ae13924ffd51510a3712c5d55">~LOutput</a> ()</td></tr>
<tr class="memdesc:ad154579ae13924ffd51510a3712c5d55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class.  <a href="class_louvre_1_1_l_output.html#ad154579ae13924ffd51510a3712c5d55">More...</a><br /></td></tr>
<tr class="separator:ad154579ae13924ffd51510a3712c5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ea938a95be538d1c94c1e4dd7327b93"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a7ea938a95be538d1c94c1e4dd7327b93">state</a> () const</td></tr>
<tr class="memdesc:a7ea938a95be538d1c94c1e4dd7327b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current state of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>.  <a href="class_louvre_1_1_l_output.html#a7ea938a95be538d1c94c1e4dd7327b93">More...</a><br /></td></tr>
<tr class="separator:a7ea938a95be538d1c94c1e4dd7327b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fb03423f4b24fb0cf4b552c83a5ad25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_framebuffer.html">LFramebuffer</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a6fb03423f4b24fb0cf4b552c83a5ad25">framebuffer</a> () const</td></tr>
<tr class="memdesc:a6fb03423f4b24fb0cf4b552c83a5ad25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a pointer to the associated framebuffer.  <a href="class_louvre_1_1_l_output.html#a6fb03423f4b24fb0cf4b552c83a5ad25">More...</a><br /></td></tr>
<tr class="separator:a6fb03423f4b24fb0cf4b552c83a5ad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2580e2123d1eaab1b71e64cdb30adb1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36">LFramebuffer::Transform</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a2580e2123d1eaab1b71e64cdb30adb1b">transform</a> () const</td></tr>
<tr class="memdesc:a2580e2123d1eaab1b71e64cdb30adb1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the framebuffer transformation.  <a href="class_louvre_1_1_l_output.html#a2580e2123d1eaab1b71e64cdb30adb1b">More...</a><br /></td></tr>
<tr class="separator:a2580e2123d1eaab1b71e64cdb30adb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f46e1d3500815df2b14c9c7e1035e5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5f46e1d3500815df2b14c9c7e1035e5b">setTransform</a> (<a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36">LFramebuffer::Transform</a> <a class="el" href="class_louvre_1_1_l_output.html#a2580e2123d1eaab1b71e64cdb30adb1b">transform</a>)</td></tr>
<tr class="memdesc:a5f46e1d3500815df2b14c9c7e1035e5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the framebuffer transformation.  <a href="class_louvre_1_1_l_output.html#a5f46e1d3500815df2b14c9c7e1035e5b">More...</a><br /></td></tr>
<tr class="separator:a5f46e1d3500815df2b14c9c7e1035e5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdb29140a78d6490e8ba19be655ac636"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#afdb29140a78d6490e8ba19be655ac636">currentBuffer</a> () const</td></tr>
<tr class="memdesc:afdb29140a78d6490e8ba19be655ac636"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the index of the current buffer.  <a href="class_louvre_1_1_l_output.html#afdb29140a78d6490e8ba19be655ac636">More...</a><br /></td></tr>
<tr class="separator:afdb29140a78d6490e8ba19be655ac636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ddb848d60179d7bf365d2ec4fb0d8a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a8ddb848d60179d7bf365d2ec4fb0d8a7">buffersCount</a> () const</td></tr>
<tr class="memdesc:a8ddb848d60179d7bf365d2ec4fb0d8a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the count of available buffers.  <a href="class_louvre_1_1_l_output.html#a8ddb848d60179d7bf365d2ec4fb0d8a7">More...</a><br /></td></tr>
<tr class="separator:a8ddb848d60179d7bf365d2ec4fb0d8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed3f6d4269d86fdf9f50553fe1f0005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a7ed3f6d4269d86fdf9f50553fe1f0005">bufferTexture</a> (<a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> bufferIndex)</td></tr>
<tr class="memdesc:a7ed3f6d4269d86fdf9f50553fe1f0005"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the texture of a specific buffer.  <a href="class_louvre_1_1_l_output.html#a7ed3f6d4269d86fdf9f50553fe1f0005">More...</a><br /></td></tr>
<tr class="separator:a7ed3f6d4269d86fdf9f50553fe1f0005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786ae60b811ad29cb07f852d7ab8e905"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a786ae60b811ad29cb07f852d7ab8e905">hasBufferDamageSupport</a> () const</td></tr>
<tr class="memdesc:a786ae60b811ad29cb07f852d7ab8e905"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if the output supports buffer damage tracking.  <a href="class_louvre_1_1_l_output.html#a786ae60b811ad29cb07f852d7ab8e905">More...</a><br /></td></tr>
<tr class="separator:a786ae60b811ad29cb07f852d7ab8e905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f589c569c0af078f9b537499b2876f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a5f589c569c0af078f9b537499b2876f2">setBufferDamage</a> (const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> *damage)</td></tr>
<tr class="memdesc:a5f589c569c0af078f9b537499b2876f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the damaged region of the framebuffer.  <a href="class_louvre_1_1_l_output.html#a5f589c569c0af078f9b537499b2876f2">More...</a><br /></td></tr>
<tr class="separator:a5f589c569c0af078f9b537499b2876f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4119439634159da2512eb58d72f32a70"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a4119439634159da2512eb58d72f32a70">subPixel</a> () const</td></tr>
<tr class="memdesc:a4119439634159da2512eb58d72f32a70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the layout of RGB subpixels for a single pixel on a display.  <a href="class_louvre_1_1_l_output.html#a4119439634159da2512eb58d72f32a70">More...</a><br /></td></tr>
<tr class="separator:a4119439634159da2512eb58d72f32a70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f9110b6e467f56dfb685413a34b55ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3f9110b6e467f56dfb685413a34b55ca">hasVSyncControlSupport</a> () const</td></tr>
<tr class="memdesc:a3f9110b6e467f56dfb685413a34b55ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if VSync control is supported for this output.  <a href="class_louvre_1_1_l_output.html#a3f9110b6e467f56dfb685413a34b55ca">More...</a><br /></td></tr>
<tr class="separator:a3f9110b6e467f56dfb685413a34b55ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c4d06b8b595b585b3dae76cd5798d6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ae9c4d06b8b595b585b3dae76cd5798d6">vSyncEnabled</a> () const</td></tr>
<tr class="memdesc:ae9c4d06b8b595b585b3dae76cd5798d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if VSync is enabled (enabled by default).  <a href="class_louvre_1_1_l_output.html#ae9c4d06b8b595b585b3dae76cd5798d6">More...</a><br /></td></tr>
<tr class="separator:ae9c4d06b8b595b585b3dae76cd5798d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addc8f19aa2482bc6da68fdab581503db"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#addc8f19aa2482bc6da68fdab581503db">enableVSync</a> (bool enabled)</td></tr>
<tr class="memdesc:addc8f19aa2482bc6da68fdab581503db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Turns VSync on or off.  <a href="class_louvre_1_1_l_output.html#addc8f19aa2482bc6da68fdab581503db">More...</a><br /></td></tr>
<tr class="separator:addc8f19aa2482bc6da68fdab581503db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9090006a187f3dd431d4b07da97f2984"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9090006a187f3dd431d4b07da97f2984">refreshRateLimit</a> () const</td></tr>
<tr class="memdesc:a9090006a187f3dd431d4b07da97f2984"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the refresh rate limit in Hz when VSync is disabled.  <a href="class_louvre_1_1_l_output.html#a9090006a187f3dd431d4b07da97f2984">More...</a><br /></td></tr>
<tr class="separator:a9090006a187f3dd431d4b07da97f2984"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71872b743bd73927fb723cf56e8ed0aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a71872b743bd73927fb723cf56e8ed0aa">setRefreshRateLimit</a> (<a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> hz)</td></tr>
<tr class="memdesc:a71872b743bd73927fb723cf56e8ed0aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the refresh rate limit in Hz when VSync is disabled.  <a href="class_louvre_1_1_l_output.html#a71872b743bd73927fb723cf56e8ed0aa">More...</a><br /></td></tr>
<tr class="separator:a71872b743bd73927fb723cf56e8ed0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3526adc24e3f23a42cbf50a625569cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3526adc24e3f23a42cbf50a625569cfd">gammaSize</a> () const</td></tr>
<tr class="memdesc:a3526adc24e3f23a42cbf50a625569cfd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the size of the gamma table.  <a href="class_louvre_1_1_l_output.html#a3526adc24e3f23a42cbf50a625569cfd">More...</a><br /></td></tr>
<tr class="separator:a3526adc24e3f23a42cbf50a625569cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fbc1687049fe0f0361cf1f81cc47f5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3fbc1687049fe0f0361cf1f81cc47f5a">setGamma</a> (const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *gamma)</td></tr>
<tr class="memdesc:a3fbc1687049fe0f0361cf1f81cc47f5a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the gamma correction table for the output.  <a href="class_louvre_1_1_l_output.html#a3fbc1687049fe0f0361cf1f81cc47f5a">More...</a><br /></td></tr>
<tr class="separator:a3fbc1687049fe0f0361cf1f81cc47f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac403f8d9086b7b95588c0fd6284962"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9ac403f8d9086b7b95588c0fd6284962">modes</a> () const</td></tr>
<tr class="memdesc:a9ac403f8d9086b7b95588c0fd6284962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector of available modes.  <a href="class_louvre_1_1_l_output.html#a9ac403f8d9086b7b95588c0fd6284962">More...</a><br /></td></tr>
<tr class="separator:a9ac403f8d9086b7b95588c0fd6284962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22d0dc29c25b8e272daa2818dd81668"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ab22d0dc29c25b8e272daa2818dd81668">preferredMode</a> () const</td></tr>
<tr class="memdesc:ab22d0dc29c25b8e272daa2818dd81668"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the preferred mode.  <a href="class_louvre_1_1_l_output.html#ab22d0dc29c25b8e272daa2818dd81668">More...</a><br /></td></tr>
<tr class="separator:ab22d0dc29c25b8e272daa2818dd81668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adaa838a2c2a51dca54cbe4925a2d84"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3adaa838a2c2a51dca54cbe4925a2d84">currentMode</a> () const</td></tr>
<tr class="memdesc:a3adaa838a2c2a51dca54cbe4925a2d84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current mode.  <a href="class_louvre_1_1_l_output.html#a3adaa838a2c2a51dca54cbe4925a2d84">More...</a><br /></td></tr>
<tr class="separator:a3adaa838a2c2a51dca54cbe4925a2d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125f832b1a5e470d494a0b3d1edbda2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a125f832b1a5e470d494a0b3d1edbda2e">setMode</a> (const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *mode)</td></tr>
<tr class="memdesc:a125f832b1a5e470d494a0b3d1edbda2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output mode.  <a href="class_louvre_1_1_l_output.html#a125f832b1a5e470d494a0b3d1edbda2e">More...</a><br /></td></tr>
<tr class="separator:a125f832b1a5e470d494a0b3d1edbda2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c093b0223c7591bbbc877fc8e8392e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e">setScale</a> (<a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> <a class="el" href="class_louvre_1_1_l_output.html#a9b81bd5b3d166c724e07edb5255a63bf">scale</a>)</td></tr>
<tr class="memdesc:a10c093b0223c7591bbbc877fc8e8392e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the output scale factor.  <a href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e">More...</a><br /></td></tr>
<tr class="separator:a10c093b0223c7591bbbc877fc8e8392e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b81bd5b3d166c724e07edb5255a63bf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a9b81bd5b3d166c724e07edb5255a63bf">scale</a> () const</td></tr>
<tr class="memdesc:a9b81bd5b3d166c724e07edb5255a63bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve the current output scale factor.  <a href="class_louvre_1_1_l_output.html#a9b81bd5b3d166c724e07edb5255a63bf">More...</a><br /></td></tr>
<tr class="separator:a9b81bd5b3d166c724e07edb5255a63bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d405a34a830b76eee2ceaa396057bd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a3d405a34a830b76eee2ceaa396057bd5">fractionalScale</a> () const</td></tr>
<tr class="memdesc:a3d405a34a830b76eee2ceaa396057bd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the same scale set with <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a>.  <a href="class_louvre_1_1_l_output.html#a3d405a34a830b76eee2ceaa396057bd5">More...</a><br /></td></tr>
<tr class="separator:a3d405a34a830b76eee2ceaa396057bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1460753a3ddbf7c499b0ceae67275970"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a1460753a3ddbf7c499b0ceae67275970">usingFractionalScale</a> () const</td></tr>
<tr class="memdesc:a1460753a3ddbf7c499b0ceae67275970"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if the scale factor set with <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a> is fractional.  <a href="class_louvre_1_1_l_output.html#a1460753a3ddbf7c499b0ceae67275970">More...</a><br /></td></tr>
<tr class="separator:a1460753a3ddbf7c499b0ceae67275970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6de0d46bc3bfe16855ebcfeaf7eab1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#abe6de0d46bc3bfe16855ebcfeaf7eab1">fractionalOversamplingEnabled</a> () const</td></tr>
<tr class="memdesc:abe6de0d46bc3bfe16855ebcfeaf7eab1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if oversampling is enabled.  <a href="class_louvre_1_1_l_output.html#abe6de0d46bc3bfe16855ebcfeaf7eab1">More...</a><br /></td></tr>
<tr class="separator:abe6de0d46bc3bfe16855ebcfeaf7eab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cc14aa351b8cda936faedcfdae8b29"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a44cc14aa351b8cda936faedcfdae8b29">enableFractionalOversampling</a> (bool enabled)</td></tr>
<tr class="memdesc:a44cc14aa351b8cda936faedcfdae8b29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enable or disable oversampling for fractional scales.  <a href="class_louvre_1_1_l_output.html#a44cc14aa351b8cda936faedcfdae8b29">More...</a><br /></td></tr>
<tr class="separator:a44cc14aa351b8cda936faedcfdae8b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac827b978aa122f136a14c198687ad80f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f">repaint</a> ()</td></tr>
<tr class="memdesc:ac827b978aa122f136a14c198687ad80f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Schedule the next rendering frame.  <a href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f">More...</a><br /></td></tr>
<tr class="separator:ac827b978aa122f136a14c198687ad80f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41e22b342e308131ea3e359c536506c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad41e22b342e308131ea3e359c536506c">dpi</a> ()</td></tr>
<tr class="memdesc:ad41e22b342e308131ea3e359c536506c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the dots per inch (DPI) of the output.  <a href="class_louvre_1_1_l_output.html#ad41e22b342e308131ea3e359c536506c">More...</a><br /></td></tr>
<tr class="separator:ad41e22b342e308131ea3e359c536506c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ed3cb99ef4b81ad9a1a3ba169c4abd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ac0ed3cb99ef4b81ad9a1a3ba169c4abd">physicalSize</a> () const</td></tr>
<tr class="memdesc:ac0ed3cb99ef4b81ad9a1a3ba169c4abd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the physical dimensions of the output.  <a href="class_louvre_1_1_l_output.html#ac0ed3cb99ef4b81ad9a1a3ba169c4abd">More...</a><br /></td></tr>
<tr class="separator:ac0ed3cb99ef4b81ad9a1a3ba169c4abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a343fa3c04ce3d38c00d98283b1a49528"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528">size</a> () const</td></tr>
<tr class="memdesc:a343fa3c04ce3d38c00d98283b1a49528"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output size in compositor coordinates.  <a href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528">More...</a><br /></td></tr>
<tr class="separator:a343fa3c04ce3d38c00d98283b1a49528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621c2f27deb1f09df42690f9d64231fc"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc">sizeB</a> () const</td></tr>
<tr class="memdesc:a621c2f27deb1f09df42690f9d64231fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output size in buffer coordinates.  <a href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc">More...</a><br /></td></tr>
<tr class="separator:a621c2f27deb1f09df42690f9d64231fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbe7dd7c81791c49ac9c4a2e73bb4271"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271">rect</a> () const</td></tr>
<tr class="memdesc:abbe7dd7c81791c49ac9c4a2e73bb4271"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output rect.  <a href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271">More...</a><br /></td></tr>
<tr class="separator:abbe7dd7c81791c49ac9c4a2e73bb4271"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c53ee6f58ab78ab3f37bf85639dd6ec"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">LPoint</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">pos</a> () const</td></tr>
<tr class="memdesc:a2c53ee6f58ab78ab3f37bf85639dd6ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output position in surface coordinates.  <a href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">More...</a><br /></td></tr>
<tr class="separator:a2c53ee6f58ab78ab3f37bf85639dd6ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd9b75c5594e4fa1e61839aa211f4740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#abd9b75c5594e4fa1e61839aa211f4740">setPos</a> (const <a class="el" href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">LPoint</a> &amp;<a class="el" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">pos</a>)</td></tr>
<tr class="memdesc:abd9b75c5594e4fa1e61839aa211f4740"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the position of the output.  <a href="class_louvre_1_1_l_output.html#abd9b75c5594e4fa1e61839aa211f4740">More...</a><br /></td></tr>
<tr class="separator:abd9b75c5594e4fa1e61839aa211f4740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860a900733b4494b77121df7259a064f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a860a900733b4494b77121df7259a064f">name</a> () const</td></tr>
<tr class="memdesc:a860a900733b4494b77121df7259a064f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output name.  <a href="class_louvre_1_1_l_output.html#a860a900733b4494b77121df7259a064f">More...</a><br /></td></tr>
<tr class="separator:a860a900733b4494b77121df7259a064f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b373862663fb6e8d47e62af25953fc1"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a8b373862663fb6e8d47e62af25953fc1">model</a> () const</td></tr>
<tr class="memdesc:a8b373862663fb6e8d47e62af25953fc1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the output model name.  <a href="class_louvre_1_1_l_output.html#a8b373862663fb6e8d47e62af25953fc1">More...</a><br /></td></tr>
<tr class="separator:a8b373862663fb6e8d47e62af25953fc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070360cb2e6446243d34b4d7b0b35797"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a070360cb2e6446243d34b4d7b0b35797">manufacturer</a> () const</td></tr>
<tr class="memdesc:a070360cb2e6446243d34b4d7b0b35797"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the manufacturer name of the output.  <a href="class_louvre_1_1_l_output.html#a070360cb2e6446243d34b4d7b0b35797">More...</a><br /></td></tr>
<tr class="separator:a070360cb2e6446243d34b4d7b0b35797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc7efa32be9e56ba2bbfd001395f803"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#abdc7efa32be9e56ba2bbfd001395f803">description</a> () const</td></tr>
<tr class="memdesc:abdc7efa32be9e56ba2bbfd001395f803"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the description of the output.  <a href="class_louvre_1_1_l_output.html#abdc7efa32be9e56ba2bbfd001395f803">More...</a><br /></td></tr>
<tr class="separator:abdc7efa32be9e56ba2bbfd001395f803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf92efe31f8609499bdb7512fef190b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_louvre_1_1_l_painter.html">LPainter</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b">painter</a> () const</td></tr>
<tr class="memdesc:aebf92efe31f8609499bdb7512fef190b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get access to the associated <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a>.  <a href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b">More...</a><br /></td></tr>
<tr class="separator:aebf92efe31f8609499bdb7512fef190b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8cdd7e4a167b5b841be9d0beac83fd"><td class="memItemLeft" align="right" valign="top">const std::thread::id &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aed8cdd7e4a167b5b841be9d0beac83fd">threadId</a> () const</td></tr>
<tr class="memdesc:aed8cdd7e4a167b5b841be9d0beac83fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID of the rendering thread.  <a href="class_louvre_1_1_l_output.html#aed8cdd7e4a167b5b841be9d0beac83fd">More...</a><br /></td></tr>
<tr class="separator:aed8cdd7e4a167b5b841be9d0beac83fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual Methods</div></td></tr>
<tr class="memitem:a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">initializeGL</a> ()</td></tr>
<tr class="memdesc:a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize Event.  <a href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">More...</a><br /></td></tr>
<tr class="separator:a2aeeb1c8e8bb0f723ebb7129df23d4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0569e991ee4c6e4242578aca6d999741"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">paintGL</a> ()</td></tr>
<tr class="memdesc:a0569e991ee4c6e4242578aca6d999741"><td class="mdescLeft">&#160;</td><td class="mdescRight">Paint Event.  <a href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">More...</a><br /></td></tr>
<tr class="separator:a0569e991ee4c6e4242578aca6d999741"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4dc5e1f724869e9523ce872afd56a1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">resizeGL</a> ()</td></tr>
<tr class="memdesc:ad4dc5e1f724869e9523ce872afd56a1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resize Event.  <a href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">More...</a><br /></td></tr>
<tr class="separator:ad4dc5e1f724869e9523ce872afd56a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15f67e7da7f9351890b2c6258ee9225"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">moveGL</a> ()</td></tr>
<tr class="memdesc:aa15f67e7da7f9351890b2c6258ee9225"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move Event.  <a href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">More...</a><br /></td></tr>
<tr class="separator:aa15f67e7da7f9351890b2c6258ee9225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a454d002ee90273a44dfb59a30246129e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">uninitializeGL</a> ()</td></tr>
<tr class="memdesc:a454d002ee90273a44dfb59a30246129e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Uninitialize Event.  <a href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">More...</a><br /></td></tr>
<tr class="separator:a454d002ee90273a44dfb59a30246129e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">setGammaRequest</a> (<a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *client, const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *gamma)</td></tr>
<tr class="memdesc:a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set gamma table request.  <a href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">More...</a><br /></td></tr>
<tr class="separator:a386f3d06f6c9f2d60e66c6da5bf3dd1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:a92c55666ee1af47322c7f144a411bbf1 inherit pub_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a92c55666ee1af47322c7f144a411bbf1">LObject</a> ()=default</td></tr>
<tr class="memdesc:a92c55666ee1af47322c7f144a411bbf1 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <a href="class_louvre_1_1_l_object.html#a92c55666ee1af47322c7f144a411bbf1">More...</a><br /></td></tr>
<tr class="separator:a92c55666ee1af47322c7f144a411bbf1 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322bea994ede96d6175b3c1f82ca6993 inherit pub_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a322bea994ede96d6175b3c1f82ca6993">~LObject</a> ()</td></tr>
<tr class="memdesc:a322bea994ede96d6175b3c1f82ca6993 inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor of the <a class="el" href="class_louvre_1_1_l_object.html" title="Base class for Louvre objects.">LObject</a> class.  <a href="class_louvre_1_1_l_object.html#a322bea994ede96d6175b3c1f82ca6993">More...</a><br /></td></tr>
<tr class="separator:a322bea994ede96d6175b3c1f82ca6993 inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9072d1b23b10e15be73bf10f82ebbfce inherit pub_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a9072d1b23b10e15be73bf10f82ebbfce">isAlive</a> () const</td></tr>
<tr class="memdesc:a9072d1b23b10e15be73bf10f82ebbfce inherit pub_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Object's liveness status.  <a href="class_louvre_1_1_l_object.html#a9072d1b23b10e15be73bf10f82ebbfce">More...</a><br /></td></tr>
<tr class="separator:a9072d1b23b10e15be73bf10f82ebbfce inherit pub_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_class_louvre_1_1_l_object"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_class_louvre_1_1_l_object')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="class_louvre_1_1_l_object.html">LObject</a></td></tr>
<tr class="memitem:aec0d8359f7f779f0979418728d5b1ef8 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_louvre_1_1_l_compositor.html">LCompositor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#aec0d8359f7f779f0979418728d5b1ef8">compositor</a> ()</td></tr>
<tr class="memdesc:aec0d8359f7f779f0979418728d5b1ef8 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick access to the global compositor instance.  <a href="class_louvre_1_1_l_object.html#aec0d8359f7f779f0979418728d5b1ef8">More...</a><br /></td></tr>
<tr class="separator:aec0d8359f7f779f0979418728d5b1ef8 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70539dae4dffb5171820c166fd6b58e2 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_louvre_1_1_l_seat.html">LSeat</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a> ()</td></tr>
<tr class="memdesc:a70539dae4dffb5171820c166fd6b58e2 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick access to the global seat instance.  <a href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">More...</a><br /></td></tr>
<tr class="separator:a70539dae4dffb5171820c166fd6b58e2 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80020230648b424b9ff1c582cd9febe1 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_louvre_1_1_l_cursor.html">LCursor</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a> ()</td></tr>
<tr class="memdesc:a80020230648b424b9ff1c582cd9febe1 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="mdescLeft">&#160;</td><td class="mdescRight">Quick access to the global cursor instance.  <a href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">More...</a><br /></td></tr>
<tr class="separator:a80020230648b424b9ff1c582cd9febe1 inherit pub_static_methods_class_louvre_1_1_l_object"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a5d74787dedbc4e11c1ab15bf487e61f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d74787dedbc4e11c1ab15bf487e61f8">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">State</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of possible states for an <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8ad83e069857681eacefa2ed3ea543f21d"></a>PendingInitialize&#160;</td><td class="fielddoc"><p>Output is pending initialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a7a7304bcbfd2527762b18d301de0fd16"></a>PendingUninitialize&#160;</td><td class="fielddoc"><p>Output is pending uninitialization. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8aae32940b344dab2f4e31be660ce1ab02"></a>Initialized&#160;</td><td class="fielddoc"><p>Output is initialized and active. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a254bd1cf3c287ac4eb3d47320b1c92b6"></a>Uninitialized&#160;</td><td class="fielddoc"><p>Output is uninitialized. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a151f7ecff2156021548285c6a31ff01f"></a>ChangingMode&#160;</td><td class="fielddoc"><p>Output is in the process of changing display mode. </p>
</td></tr>
<tr><td class="fieldname"><a id="a5d74787dedbc4e11c1ab15bf487e61f8a13bd6ff4bd5714ccc293f6802aacb40d"></a>Suspended&#160;</td><td class="fielddoc"><p>Output is suspended. </p>
</td></tr>
</table>

</div>
</div>
<a id="acf3ae70a3f91b9f2d855904572dcbed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf3ae70a3f91b9f2d855904572dcbed8">&#9670;&nbsp;</a></span>SubPixel</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">SubPixel</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration describing the subpixel geometry. </p>
<p>This enumeration provides information about how the physical pixels on an output are laid out. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a4e81c184ac3ad48a389cd4454c4a05bb"></a>Unknown&#160;</td><td class="fielddoc"><p>Unknown geometry. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8ac9d3e887722f2bc482bcca9d41c512af"></a>None&#160;</td><td class="fielddoc"><p>No specific geometry. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8af6dd61d48c7e7bb981b99292d7aac1d0"></a>HorizontalRGB&#160;</td><td class="fielddoc"><p>Horizontal RGB layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a0a5e58bbb886fe45f3587a21f23acc53"></a>HorizontalBGR&#160;</td><td class="fielddoc"><p>Horizontal BGR layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8a16d7d3a5b59ca99c3be61b0da997b8c9"></a>VerticalRGB&#160;</td><td class="fielddoc"><p>Vertical RGB layout. </p>
</td></tr>
<tr><td class="fieldname"><a id="acf3ae70a3f91b9f2d855904572dcbed8ae45d01b6582fb4a2e7734d3b6bb2a7f6"></a>VerticalBGR&#160;</td><td class="fielddoc"><p>Vertical BGR layout. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac0e3199d5e20da15aaa1f7f1abb99bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e3199d5e20da15aaa1f7f1abb99bfe">&#9670;&nbsp;</a></span>LOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>params</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class. </p>

</div>
</div>
<a id="ad154579ae13924ffd51510a3712c5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad154579ae13924ffd51510a3712c5d55">&#9670;&nbsp;</a></span>~LOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">~<a class="el" href="class_louvre_1_1_l_output.html">LOutput</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> class. </p>
<p>Invoked internally by the library after <a class="el" href="class_louvre_1_1_l_compositor.html#abba88891ebb04dd3e5b992eb89e13ed3" title="Virtual destructor for the LOutput class.">LCompositor::destroyOutputRequest()</a> is called. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7ea938a95be538d1c94c1e4dd7327b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ea938a95be538d1c94c1e4dd7327b93">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html#a5d74787dedbc4e11c1ab15bf487e61f8">LOutput::State</a> state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current state of the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a>. </p>
<p>This method returns the current state of the output. </p>

</div>
</div>
<a id="a6fb03423f4b24fb0cf4b552c83a5ad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fb03423f4b24fb0cf4b552c83a5ad25">&#9670;&nbsp;</a></span>framebuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_framebuffer.html">LFramebuffer</a> * framebuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a pointer to the associated framebuffer. </p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the <a class="el" href="class_louvre_1_1_l_framebuffer.html" title="Base class for creating framebuffers.">LFramebuffer</a> instance associated with the output. </dd></dl>

</div>
</div>
<a id="a2580e2123d1eaab1b71e64cdb30adb1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2580e2123d1eaab1b71e64cdb30adb1b">&#9670;&nbsp;</a></span>transform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36">LFramebuffer::Transform</a> transform </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the framebuffer transformation. </p>
<p>This method returns the current framebuffer transformation applied with <a class="el" href="class_louvre_1_1_l_output.html#a5f46e1d3500815df2b14c9c7e1035e5b" title="Set the framebuffer transformation.">setTransform()</a>. The default value is <a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36a5ecbcf0afce98b042f35ec71ba03fa4b" title="No transformation.">LFramebuffer::Normal</a>.</p>
<dl class="section return"><dt>Returns</dt><dd>The framebuffer transformation. </dd></dl>

</div>
</div>
<a id="a5f46e1d3500815df2b14c9c7e1035e5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f46e1d3500815df2b14c9c7e1035e5b">&#9670;&nbsp;</a></span>setTransform()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setTransform </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_framebuffer.html#a26781e480e4f6bf116aae127eefdff36">LFramebuffer::Transform</a>&#160;</td>
          <td class="paramname"><em>transform</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the framebuffer transformation. </p>
<p>This method sets the transformation for the framebuffer, allowing you to adjust the orientation of the output. If the specified transformation includes a 90 or 270-degree rotation, the width and height of the output are swapped accordingly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">transform</td><td>The framebuffer transformation to apply. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afdb29140a78d6490e8ba19be655ac636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdb29140a78d6490e8ba19be655ac636">&#9670;&nbsp;</a></span>currentBuffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> currentBuffer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the index of the current buffer. </p>
<p>Compositors commonly employ double or triple buffering to ensure smooth graphics rendering. This involves rendering to one buffer while displaying another, reducing visual artifacts like glitches and tearing.</p>
<div class="image">
<img src="https://lh3.googleusercontent.com/2ousoWwxnVGvFX5bT6ual2G8UUbhUOJ21mK1UQmthPNM-7XfracRlL5GCYBQTzt4Os28eKO_FzC6BS-rasiNngvTMI9lEdET0ItKrI2wK_9IwSDaF-hNGkTMI6gVlL0m4ENDJYbckw" alt=""/>
</div>
<dl class="section return"><dt>Returns</dt><dd>The current buffer index. Alternates between [0], [0, 1] or [0, 1, 2] depending on the graphic backend configuration.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a href="md_md__environment.html#graphic">Graphic Backend Configuration</a> </dd></dl>

</div>
</div>
<a id="a8ddb848d60179d7bf365d2ec4fb0d8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ddb848d60179d7bf365d2ec4fb0d8a7">&#9670;&nbsp;</a></span>buffersCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> buffersCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the count of available buffers. </p>
<p>This method returns the number of buffers used by the output. It can be 1, 2 or 3 depending on the graphic backend configuration.</p>
<dl class="section see"><dt>See also</dt><dd><a href="md_md__environment.html#graphic">Graphic Backend Configuration</a> </dd></dl>

</div>
</div>
<a id="a7ed3f6d4269d86fdf9f50553fe1f0005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed3f6d4269d86fdf9f50553fe1f0005">&#9670;&nbsp;</a></span>bufferTexture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_texture.html">LTexture</a> * bufferTexture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a>&#160;</td>
          <td class="paramname"><em>bufferIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Access the texture of a specific buffer. </p>
<p>This method allows access to the texture associated with a particular buffer index.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">bufferIndex</td><td>The index of the buffer for which the texture is to be accessed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the texture associated with the specified buffer index, or <code>nullptr</code> if texture access is not supported.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>Some hardware/backends may not support accessing outputs textures, so you should always check if <code>nullptr</code> is returned. </dd></dl>

</div>
</div>
<a id="a786ae60b811ad29cb07f852d7ab8e905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786ae60b811ad29cb07f852d7ab8e905">&#9670;&nbsp;</a></span>hasBufferDamageSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasBufferDamageSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if the output supports buffer damage tracking. </p>
<p>Some graphic backends/hardware can benefit from knowing which regions of the framebuffer have changed within a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. This method indicates whether buffer damage support is available.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a5f589c569c0af078f9b537499b2876f2" title="Specify the damaged region of the framebuffer.">setBufferDamage()</a></dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the graphical backend supports buffer damage tracking, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a5f589c569c0af078f9b537499b2876f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f589c569c0af078f9b537499b2876f2">&#9670;&nbsp;</a></span>setBufferDamage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setBufferDamage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_region.html">LRegion</a> *&#160;</td>
          <td class="paramname"><em>damage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the damaged region of the framebuffer. </p>
<p>This method is used to designate the region of the framebuffer that has been affected in the most recent <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. It should be invoked after completing all painting operations during a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. The damage region is automatically cleared just before the subsequent <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</p>
<dl class="section note"><dt>Note</dt><dd>Although calling this method is not mandatory, it can significantly enhance performance, especially on certain graphic backends/hardware or when the output scale is fractional and oversampling is enabled. If never invoked, the entire output is considered damaged.</dd></dl>
<p>When using <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">LScene</a> for rendering, damage calculation is handled automatically, and calling this method should be avoided.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">damage</td><td>The damaged region of the framebuffer in surface coordinates. Providing an empty region indicates no damage, while passing <code>nullptr</code> implies the entire output is damaged. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4119439634159da2512eb58d72f32a70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4119439634159da2512eb58d72f32a70">&#9670;&nbsp;</a></span>subPixel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_output.html#acf3ae70a3f91b9f2d855904572dcbed8">LOutput::SubPixel</a> subPixel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the layout of RGB subpixels for a single pixel on a display. </p>
<p>The layout of subpixels can impact the display of elements like fonts. </p>

</div>
</div>
<a id="a3f9110b6e467f56dfb685413a34b55ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f9110b6e467f56dfb685413a34b55ca">&#9670;&nbsp;</a></span>hasVSyncControlSupport()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool hasVSyncControlSupport </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if VSync control is supported for this output. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync control is supported, <code>false</code> if VSync is always enabled. </dd></dl>

</div>
</div>
<a id="ae9c4d06b8b595b585b3dae76cd5798d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c4d06b8b595b585b3dae76cd5798d6">&#9670;&nbsp;</a></span>vSyncEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vSyncEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if VSync is enabled (enabled by default). </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync is enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="addc8f19aa2482bc6da68fdab581503db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc8f19aa2482bc6da68fdab581503db">&#9670;&nbsp;</a></span>enableVSync()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool enableVSync </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Turns VSync on or off. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable VSync, <code>false</code> to disable.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if VSync was successfully enabled or disabled, <code>false</code> if VSync control is not supported (see <a class="el" href="class_louvre_1_1_l_output.html#a3f9110b6e467f56dfb685413a34b55ca" title="Checks if VSync control is supported for this output.">hasVSyncControlSupport()</a>). </dd></dl>

</div>
</div>
<a id="a9090006a187f3dd431d4b07da97f2984"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9090006a187f3dd431d4b07da97f2984">&#9670;&nbsp;</a></span>refreshRateLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> refreshRateLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the refresh rate limit in Hz when VSync is disabled. </p>
<p>A value less than 0 indicates the limit is disabled.<br  />
A value equal to 0 indicates the limit is double the current output mode refresh rate (the default).<br  />
Any other positive value represents the limit in Hz.</p>
<dl class="section return"><dt>Returns</dt><dd>The refresh rate limit when VSync is disabled. </dd></dl>

</div>
</div>
<a id="a71872b743bd73927fb723cf56e8ed0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71872b743bd73927fb723cf56e8ed0aa">&#9670;&nbsp;</a></span>setRefreshRateLimit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setRefreshRateLimit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a>&#160;</td>
          <td class="paramname"><em>hz</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the refresh rate limit in Hz when VSync is disabled. </p>
<p>A value less than 0 indicates the limit is disabled.<br  />
A value equal to 0 indicates the limit is double the current output mode refresh rate (the default).<br  />
Any other positive value represents the limit in Hz.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hz</td><td>The refresh rate limit in Hz when VSync is disabled. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3526adc24e3f23a42cbf50a625569cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3526adc24e3f23a42cbf50a625569cfd">&#9670;&nbsp;</a></span>gammaSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a7e8aeec7b6541935dfc6f608cd5170ce">UInt32</a> gammaSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the size of the gamma table. </p>
<dl class="section note"><dt>Note</dt><dd>This method can only be called while the output is initialized. If called when not initialized, it returns 0. If the output doesn't support gamma correction, this method also returns 0.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>The size of the gamma correction table.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a3fbc1687049fe0f0361cf1f81cc47f5a" title="Sets the gamma correction table for the output.">setGamma()</a> </dd>
<dd>
<a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> </dd></dl>

</div>
</div>
<a id="a3fbc1687049fe0f0361cf1f81cc47f5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fbc1687049fe0f0361cf1f81cc47f5a">&#9670;&nbsp;</a></span>setGamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool setGamma </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *&#160;</td>
          <td class="paramname"><em>gamma</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the gamma correction table for the output. </p>
<p>This method allows to set the gamma correction table for the output.</p>
<dl class="section note"><dt>Note</dt><dd>This method can only be called while the output is initialized. <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> automatically sets a linear gamma table when the output is initialized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gamma</td><td>A pointer to the <a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> with a size matching <a class="el" href="class_louvre_1_1_l_output.html#a3526adc24e3f23a42cbf50a625569cfd" title="Gets the size of the gamma table.">gammaSize()</a>. Passing <code>nullptr</code> restores the default table (linear).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the gamma correction table was successfully set, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a9ac403f8d9086b7b95588c0fd6284962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac403f8d9086b7b95588c0fd6284962">&#9670;&nbsp;</a></span>modes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * &gt; &amp; modes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector of available modes. </p>
<p>This method returns a vector containing all the available output modes for the <a class="el" href="class_louvre_1_1_l_output.html" title="A display rendering interface.">LOutput</a> instance.</p>
<dl class="section return"><dt>Returns</dt><dd>A vector of pointers to <a class="el" href="class_louvre_1_1_l_output_mode.html" title="Output resolution and refresh rate.">LOutputMode</a> instances representing the available modes of the output. </dd></dl>

</div>
</div>
<a id="ab22d0dc29c25b8e272daa2818dd81668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22d0dc29c25b8e272daa2818dd81668">&#9670;&nbsp;</a></span>preferredMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * preferredMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the preferred mode. </p>
<p>This method returns the preferred mode for the output. It is generally the mode with the highest refresh rate and resolution. </p>

</div>
</div>
<a id="a3adaa838a2c2a51dca54cbe4925a2d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adaa838a2c2a51dca54cbe4925a2d84">&#9670;&nbsp;</a></span>currentMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> * currentMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current mode. </p>
<p>This method returns the current output mode. </p>

</div>
</div>
<a id="a125f832b1a5e470d494a0b3d1edbda2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125f832b1a5e470d494a0b3d1edbda2e">&#9670;&nbsp;</a></span>setMode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setMode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_output_mode.html">LOutputMode</a> *&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output mode. </p>
<p>Use this method to assign a mode to the output, which must be one of the available modes listed in <a class="el" href="class_louvre_1_1_l_output.html#a9ac403f8d9086b7b95588c0fd6284962" title="Vector of available modes.">modes()</a>. If the mode changes and the output is already initialized the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is triggered.</p>
<dl class="section note"><dt>Note</dt><dd>Calling this method from any of the <code>GL</code> events is not allowed, as it could potentially lead to a deadlock. In such cases, the method is simply ignored to prevent issues. </dd></dl>

</div>
</div>
<a id="a10c093b0223c7591bbbc877fc8e8392e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c093b0223c7591bbbc877fc8e8392e">&#9670;&nbsp;</a></span>setScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a>&#160;</td>
          <td class="paramname"><em>scale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the output scale factor. </p>
<p>Use this method to adjust the scale factor of the output. By default, outputs have a scale factor of 1. Increasing the scale factor, such as setting it to 2, is often suitable for high-definition displays (when <a class="el" href="class_louvre_1_1_l_output.html#ad41e22b342e308131ea3e359c536506c" title="Get the dots per inch (DPI) of the output.">dpi()</a> &gt;= 200). It's common for clients to adapt their surface scales to match the scale of the output where they are displayed. If the scale changes and the output is already initialized, the <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event will be triggered.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from <a class="el" href="namespace_louvre.html" title="Namespaces.">Louvre</a> version 1.2, fractional scales are now supported, see the <a class="el" href="class_louvre_1_1_l_output.html#Scaling">Scaling Section</a>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>The desired scale factor to set.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>See an example of its use in the default implementation of <a class="el" href="class_louvre_1_1_l_compositor.html#a7916bd2f47b5b148cdb52d0f7c7803a3" title="Notifies a successful compositor initialization.">LCompositor::initialized()</a>. </dd></dl>

</div>
</div>
<a id="a9b81bd5b3d166c724e07edb5255a63bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b81bd5b3d166c724e07edb5255a63bf">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> scale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve the current output scale factor. </p>
<p>This method returns the current scale factor assigned to the output using <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a>. The default scale factor is 1.</p>
<p>If the assigned scale is fractional this value is equal to ceil(scale).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_louvre_1_1_l_output.html#a3d405a34a830b76eee2ceaa396057bd5" title="Gets the same scale set with setScale().">fractionalScale()</a> </dd></dl>

</div>
</div>
<a id="a3d405a34a830b76eee2ceaa396057bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d405a34a830b76eee2ceaa396057bd5">&#9670;&nbsp;</a></span>fractionalScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a87d38f886e617ced2698fc55afa07637">Float32</a> fractionalScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the same scale set with <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a>. </p>
<p>Set to 1.f by default.</p>
<dl class="section return"><dt>Returns</dt><dd>The fractional scale value. </dd></dl>

</div>
</div>
<a id="a1460753a3ddbf7c499b0ceae67275970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1460753a3ddbf7c499b0ceae67275970">&#9670;&nbsp;</a></span>usingFractionalScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool usingFractionalScale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if the scale factor set with <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a> is fractional. </p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if the scale factor is fractional, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="abe6de0d46bc3bfe16855ebcfeaf7eab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6de0d46bc3bfe16855ebcfeaf7eab1">&#9670;&nbsp;</a></span>fractionalOversamplingEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool fractionalOversamplingEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if oversampling is enabled. </p>
<p>Oversampling is enabled by default when a fractional scale is set using <a class="el" href="class_louvre_1_1_l_output.html#a10c093b0223c7591bbbc877fc8e8392e" title="Set the output scale factor.">setScale()</a>. It is always disabled when using an integer scale. You can disable oversampling using <a class="el" href="class_louvre_1_1_l_output.html#a44cc14aa351b8cda936faedcfdae8b29" title="Enable or disable oversampling for fractional scales.">enableFractionalOversampling()</a>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if oversampling is enabled, <code>false</code> otherwise. </dd></dl>

</div>
</div>
<a id="a44cc14aa351b8cda936faedcfdae8b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cc14aa351b8cda936faedcfdae8b29">&#9670;&nbsp;</a></span>enableFractionalOversampling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void enableFractionalOversampling </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>enabled</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enable or disable oversampling for fractional scales. </p>
<dl class="section note"><dt>Note</dt><dd>Oversampling is always turned off for integer scales. You can instantly turn oversampling on or off when using a fractional scale. However, it is recommended to perform a full repaint in such cases to ensure the framebuffers stay synchronized.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabled</td><td><code>true</code> to enable oversampling for fractional scales, <code>false</code> to disable. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac827b978aa122f136a14c198687ad80f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac827b978aa122f136a14c198687ad80f">&#9670;&nbsp;</a></span>repaint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void repaint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Schedule the next rendering frame. </p>
<p>Calling this method unlocks the output rendering thread, triggering a subsequent <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. Regardless of the number of <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> calls within the same frame, <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> is invoked only once.<br  />
To unlock the rendering thread again, <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> must be called within or after a <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event. </p>

</div>
</div>
<a id="ad41e22b342e308131ea3e359c536506c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad41e22b342e308131ea3e359c536506c">&#9670;&nbsp;</a></span>dpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespace_louvre.html#a20b0c262d9ef5d263888e463dfa99638">Int32</a> dpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the dots per inch (DPI) of the output. </p>
<p>This method calculates and returns the dots per inch (DPI) of the output, considering its physical dimensions and the resolution provided by its current mode. </p>

</div>
</div>
<a id="ac0ed3cb99ef4b81ad9a1a3ba169c4abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ed3cb99ef4b81ad9a1a3ba169c4abd">&#9670;&nbsp;</a></span>physicalSize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; physicalSize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the physical dimensions of the output. </p>
<p>This method retrieves the physical dimensions of the output in millimeters.</p>
<dl class="section note"><dt>Note</dt><dd>In some cases, such as when the compositor is running inside a virtual machine, the physical size may be (0,0). </dd></dl>

</div>
</div>
<a id="a343fa3c04ce3d38c00d98283b1a49528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a343fa3c04ce3d38c00d98283b1a49528">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output size in compositor coordinates. </p>
<p>This method provides the size of the output in surface coordinates, based on its current mode and scale. It is equivalent to the size given by the <a class="el" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271" title="Get the output rect.">rect()</a> method. </p>

</div>
</div>
<a id="a621c2f27deb1f09df42690f9d64231fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621c2f27deb1f09df42690f9d64231fc">&#9670;&nbsp;</a></span>sizeB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a4df5473974ae0f28f3a4967f296a657b">LSize</a> &amp; sizeB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output size in buffer coordinates. </p>
<p>This method returns the size of the output in buffer coordinates, based on its current mode.</p>
<dl class="section note"><dt>Note</dt><dd>Since the dimensions provided by this method are in buffer coordinates, they are not affected by the output scale. </dd></dl>

</div>
</div>
<a id="abbe7dd7c81791c49ac9c4a2e73bb4271"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbe7dd7c81791c49ac9c4a2e73bb4271">&#9670;&nbsp;</a></span>rect()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a> &amp; rect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output rect. </p>
<p>This method provides the position and size of the output in surface coordinates (<a class="el" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec" title="Get the output position in surface coordinates.">pos()</a>, <a class="el" href="class_louvre_1_1_l_output.html#a343fa3c04ce3d38c00d98283b1a49528" title="Get the output size in compositor coordinates.">size()</a>). </p>

</div>
</div>
<a id="a2c53ee6f58ab78ab3f37bf85639dd6ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c53ee6f58ab78ab3f37bf85639dd6ec">&#9670;&nbsp;</a></span>pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">LPoint</a> &amp; pos </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output position in surface coordinates. </p>
<p>This method retrieves the position of the output in surface coordinates assigned with <a class="el" href="class_louvre_1_1_l_output.html#abd9b75c5594e4fa1e61839aa211f4740" title="Set the position of the output.">setPos()</a>. It is equivalent to the position given by the <a class="el" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271" title="Get the output rect.">rect()</a> method. </p>

</div>
</div>
<a id="abd9b75c5594e4fa1e61839aa211f4740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd9b75c5594e4fa1e61839aa211f4740">&#9670;&nbsp;</a></span>setPos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void setPos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespace_louvre.html#af44d6a74e89490a3e257f317082c93ea">LPoint</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the position of the output. </p>
<p>This method allows you to assign the position of the output in surface coordinates, with the upper-left corner as the origin. If the position changes while the output is initialized, it will trigger the <a class="el" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225" title="Move Event.">moveGL()</a> event.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pos</td><td>The new position of the output. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a860a900733b4494b77121df7259a064f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860a900733b4494b77121df7259a064f">&#9670;&nbsp;</a></span>name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output name. </p>
<p>This method retrieves the name of the output provided by the graphic backend, such as "HDMI-A-2."</p>
<dl class="section note"><dt>Note</dt><dd>Output names are always unique, even if they belong to different GPUs. </dd></dl>

</div>
</div>
<a id="a8b373862663fb6e8d47e62af25953fc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b373862663fb6e8d47e62af25953fc1">&#9670;&nbsp;</a></span>model()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * model </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the output model name. </p>
<p>This method retrieves the model name of the output provided by the graphic backend. </p>

</div>
</div>
<a id="a070360cb2e6446243d34b4d7b0b35797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a070360cb2e6446243d34b4d7b0b35797">&#9670;&nbsp;</a></span>manufacturer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * manufacturer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the manufacturer name of the output. </p>
<p>This method retrieves the manufacturer name of the output provided by the graphic backend. </p>

</div>
</div>
<a id="abdc7efa32be9e56ba2bbfd001395f803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc7efa32be9e56ba2bbfd001395f803">&#9670;&nbsp;</a></span>description()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char * description </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the description of the output. </p>
<p>This method retrieves the description of the output provided by the graphic backend. </p>

</div>
</div>
<a id="aebf92efe31f8609499bdb7512fef190b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebf92efe31f8609499bdb7512fef190b">&#9670;&nbsp;</a></span>painter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_louvre_1_1_l_painter.html">LPainter</a> * painter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get access to the associated <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a>. </p>
<p>This method provides access to the <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a> associated with this output. </p>

</div>
</div>
<a id="aed8cdd7e4a167b5b841be9d0beac83fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8cdd7e4a167b5b841be9d0beac83fd">&#9670;&nbsp;</a></span>threadId()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::thread::id &amp; threadId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the ID of the rendering thread. </p>
<p>This method retrieves the ID of the output rendering thread. </p>

</div>
</div>
<a id="a2aeeb1c8e8bb0f723ebb7129df23d4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aeeb1c8e8bb0f723ebb7129df23d4e8">&#9670;&nbsp;</a></span>initializeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void initializeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initialize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8" title="Initialize Event.">initializeGL()</a> event is invoked by the library after the output is properly initialized.<br  />
You can override this method to initialize your shaders, programs, textures, etc.</p>
<p>The default implementation assigns the white color to clear the screen.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing painting operations here, as they won't be visible on the screen. Instead, perform painting tasks in the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="autotoc_md17"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">LOutput::initializeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b">painter</a>()-&gt;<a class="code" href="class_louvre_1_1_l_painter.html#aefda0d0d90daefa54abed0b93fd6af63">setClearColor</a>(1.f, 1.f, 1.f, 1.f);</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a2aeeb1c8e8bb0f723ebb7129df23d4e8"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a2aeeb1c8e8bb0f723ebb7129df23d4e8">Louvre::LOutput::initializeGL</a></div><div class="ttdeci">virtual void initializeGL()</div><div class="ttdoc">Initialize Event.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_aebf92efe31f8609499bdb7512fef190b"><div class="ttname"><a href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b">Louvre::LOutput::painter</a></div><div class="ttdeci">LPainter * painter() const</div><div class="ttdoc">Get access to the associated LPainter.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:352</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_painter_html_aefda0d0d90daefa54abed0b93fd6af63"><div class="ttname"><a href="class_louvre_1_1_l_painter.html#aefda0d0d90daefa54abed0b93fd6af63">Louvre::LPainter::setClearColor</a></div><div class="ttdeci">void setClearColor(Float32 r, Float32 g, Float32 b, Float32 a)</div><div class="ttdoc">Set the clear color.</div><div class="ttdef"><b>Definition:</b> LPainter.cpp:894</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a0569e991ee4c6e4242578aca6d999741"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0569e991ee4c6e4242578aca6d999741">&#9670;&nbsp;</a></span>paintGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void paintGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Paint Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event is invoked by the library after calling the <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a> method.<br  />
Override this method to perform your painting operations.</p>
<p>The default implementation clears the screen, draws the surfaces following the order of the <a class="el" href="class_louvre_1_1_l_compositor.html#aab16c67e12260e34b06b8d56d5eafd88" title="Get a list of all surfaces created by clients.">LCompositor::surfaces()</a> list, draws the cursor if the graphic backend does not support cursor composition via hardware, and finally draws the icon of a drag &amp; drop session if there was one.</p>
<dl class="section note"><dt>Note</dt><dd>The default implementation provides a basic rendering method that is quite inefficient since it redraws the entire screen every frame. Check the code of the <a href="md_md__examples.html#weston">louvre-weston-clone</a> example compositor to see how to render efficiently with <a class="el" href="class_louvre_1_1_l_painter.html" title="Utility for Painting Operations.">LPainter</a> or consider using the <a class="el" href="class_louvre_1_1_l_scene.html" title="The LScene class is an optional utility that significantly simplifies rendering.">LScene</a> and <a class="el" href="class_louvre_1_1_l_view.html" title="Base class for LScene views.">LView</a> rendering system.</dd></dl>
<h4><a class="anchor" id="autotoc_md18"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">LOutput::paintGL</a>()</div>
<div class="line">{</div>
<div class="line">    LPainter *p = <a class="code" href="class_louvre_1_1_l_output.html#aebf92efe31f8609499bdb7512fef190b">painter</a>();</div>
<div class="line"> </div>
<div class="line">    LPainter::TextureParams params;</div>
<div class="line"> </div>
<div class="line">    p-&gt;clearScreen();</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Check if a surface moved under cursor (simulating a pointer move event)</span></div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a>()-&gt;pointer()-&gt;surfaceAt(<a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;<a class="code" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">pos</a>()) != <a class="code" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a>()-&gt;pointer()-&gt;focus())</div>
<div class="line">        <a class="code" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a>()-&gt;<a class="code" href="class_louvre_1_1_l_seat.html#a57b3ac5f314cf8c1c540e1d05989080e">pointer</a>()-&gt;<a class="code" href="class_louvre_1_1_l_pointer.html#a77b9e66ab7c35df84438822d23097c56">pointerMoveEvent</a>(</div>
<div class="line">            <a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;<a class="code" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">pos</a>().x(),</div>
<div class="line">            <a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;<a class="code" href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">pos</a>().y(),</div>
<div class="line">            <span class="keyword">true</span>);</div>
<div class="line"> </div>
<div class="line">    <span class="keywordflow">if</span> (<a class="code" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a>()-&gt;dndManager()-&gt;icon())</div>
<div class="line">        <a class="code" href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">seat</a>()-&gt;<a class="code" href="class_louvre_1_1_l_seat.html#aedd1827579c590a4a37c04a52662d6b5">dndManager</a>()-&gt;<a class="code" href="class_louvre_1_1_l_d_n_d_manager.html#a9618fa33e3b2144c6fe2edd1f9f63064">icon</a>()-&gt;<a class="code" href="class_louvre_1_1_l_base_surface_role.html#a8ae775723b7b1a4f55e93bd358961b05">surface</a>()-&gt;<a class="code" href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58">raise</a>();</div>
<div class="line"> </div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Draw every surface</span></div>
<div class="line">    <span class="keywordflow">for</span> (LSurface *s : <a class="code" href="class_louvre_1_1_l_object.html#aec0d8359f7f779f0979418728d5b1ef8">compositor</a>()-&gt;surfaces())</div>
<div class="line">    {</div>
<div class="line">        <span class="comment">// Skip some surfaces</span></div>
<div class="line">        <span class="keywordflow">if</span> (!s-&gt;mapped() || s-&gt;minimized() || s-&gt;cursorRole())</div>
<div class="line">        {</div>
<div class="line">            s-&gt;requestNextFrame();</div>
<div class="line">            <span class="keywordflow">continue</span>;</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Current surface rect</span></div>
<div class="line">        <a class="code" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a> currentRect = <a class="code" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a>(</div>
<div class="line">            s-&gt;rolePos(),  <span class="comment">// Role pos in surface coords</span></div>
<div class="line">            s-&gt;size());    <span class="comment">// Surface size in surface coords</span></div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Calc which outputs intersect the surface</span></div>
<div class="line">        <span class="keywordflow">for</span> (<a class="code" href="class_louvre_1_1_l_output.html#ac0e3199d5e20da15aaa1f7f1abb99bfe">LOutput</a> *o : <a class="code" href="class_louvre_1_1_l_object.html#aec0d8359f7f779f0979418728d5b1ef8">compositor</a>()-&gt;outputs())</div>
<div class="line">        {</div>
<div class="line">            <span class="keywordflow">if</span> (o-&gt;rect().intersects(currentRect))</div>
<div class="line">                s-&gt;sendOutputEnterEvent(o);</div>
<div class="line">            <span class="keywordflow">else</span></div>
<div class="line">                s-&gt;sendOutputLeaveEvent(o);</div>
<div class="line">        }</div>
<div class="line"> </div>
<div class="line">        params.srcRect = s-&gt;srcRect();</div>
<div class="line">        params.dstSize = s-&gt;size();</div>
<div class="line">        params.srcScale = s-&gt;bufferScale();</div>
<div class="line">        params.srcTransform = s-&gt;bufferTransform();</div>
<div class="line">        params.texture = s-&gt;texture();</div>
<div class="line">        params.pos = currentRect.pos();</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Bind the surface texture</span></div>
<div class="line">        p-&gt;bindTextureMode(params);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Draw the surface</span></div>
<div class="line">        p-&gt;drawRect(currentRect);</div>
<div class="line"> </div>
<div class="line">        <span class="comment">// Notify the client it can now render a new surface frame</span></div>
<div class="line">        s-&gt;requestNextFrame();</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="comment">// Manualy draw the cursor if hardware composition is not supported</span></div>
<div class="line">    <span class="keywordflow">if</span> (!<a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;hasHardwareSupport(<span class="keyword">this</span>))</div>
<div class="line">    {</div>
<div class="line">        p-&gt;drawTexture(</div>
<div class="line">            <a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;texture(),                  </div>
<div class="line">            <a class="code" href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">LRect</a>(0, <a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;texture()-&gt;<a class="code" href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc">sizeB</a>()),</div>
<div class="line">            <a class="code" href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">cursor</a>()-&gt;<a class="code" href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271">rect</a>());</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_base_surface_role_html_a8ae775723b7b1a4f55e93bd358961b05"><div class="ttname"><a href="class_louvre_1_1_l_base_surface_role.html#a8ae775723b7b1a4f55e93bd358961b05">Louvre::LBaseSurfaceRole::surface</a></div><div class="ttdeci">LSurface * surface() const</div><div class="ttdoc">Returns the surface that has acquired the role provided in the constructor.</div><div class="ttdef"><b>Definition:</b> LBaseSurfaceRole.cpp:31</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_d_n_d_manager_html_a9618fa33e3b2144c6fe2edd1f9f63064"><div class="ttname"><a href="class_louvre_1_1_l_d_n_d_manager.html#a9618fa33e3b2144c6fe2edd1f9f63064">Louvre::LDNDManager::icon</a></div><div class="ttdeci">LDNDIconRole * icon() const</div><div class="ttdoc">Drag &amp; drop session icon.</div><div class="ttdef"><b>Definition:</b> LDNDManager.cpp:25</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_object_html_a70539dae4dffb5171820c166fd6b58e2"><div class="ttname"><a href="class_louvre_1_1_l_object.html#a70539dae4dffb5171820c166fd6b58e2">Louvre::LObject::seat</a></div><div class="ttdeci">static LSeat * seat()</div><div class="ttdoc">Quick access to the global seat instance.</div><div class="ttdef"><b>Definition:</b> LObject.h:36</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_object_html_a80020230648b424b9ff1c582cd9febe1"><div class="ttname"><a href="class_louvre_1_1_l_object.html#a80020230648b424b9ff1c582cd9febe1">Louvre::LObject::cursor</a></div><div class="ttdeci">static LCursor * cursor()</div><div class="ttdoc">Quick access to the global cursor instance.</div><div class="ttdef"><b>Definition:</b> LObject.h:44</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_object_html_aec0d8359f7f779f0979418728d5b1ef8"><div class="ttname"><a href="class_louvre_1_1_l_object.html#aec0d8359f7f779f0979418728d5b1ef8">Louvre::LObject::compositor</a></div><div class="ttdeci">static LCompositor * compositor()</div><div class="ttdoc">Quick access to the global compositor instance.</div><div class="ttdef"><b>Definition:</b> LObject.h:28</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a0569e991ee4c6e4242578aca6d999741"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741">Louvre::LOutput::paintGL</a></div><div class="ttdeci">virtual void paintGL()</div><div class="ttdoc">Paint Event.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a2c53ee6f58ab78ab3f37bf85639dd6ec"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a2c53ee6f58ab78ab3f37bf85639dd6ec">Louvre::LOutput::pos</a></div><div class="ttdeci">const LPoint &amp; pos() const</div><div class="ttdoc">Get the output position in surface coordinates.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:312</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a621c2f27deb1f09df42690f9d64231fc"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a621c2f27deb1f09df42690f9d64231fc">Louvre::LOutput::sizeB</a></div><div class="ttdeci">const LSize &amp; sizeB() const</div><div class="ttdoc">Get the output size in buffer coordinates.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:302</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_abbe7dd7c81791c49ac9c4a2e73bb4271"><div class="ttname"><a href="class_louvre_1_1_l_output.html#abbe7dd7c81791c49ac9c4a2e73bb4271">Louvre::LOutput::rect</a></div><div class="ttdeci">const LRect &amp; rect() const</div><div class="ttdoc">Get the output rect.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:307</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ac0e3199d5e20da15aaa1f7f1abb99bfe"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ac0e3199d5e20da15aaa1f7f1abb99bfe">Louvre::LOutput::LOutput</a></div><div class="ttdeci">LOutput(const void *params)</div><div class="ttdoc">Constructor of the LOutput class.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:31</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_pointer_html_a77b9e66ab7c35df84438822d23097c56"><div class="ttname"><a href="class_louvre_1_1_l_pointer.html#a77b9e66ab7c35df84438822d23097c56">Louvre::LPointer::pointerMoveEvent</a></div><div class="ttdeci">virtual void pointerMoveEvent(Float32 x, Float32 y, bool absolute)</div><div class="ttdoc">Pointer move event.</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_a57b3ac5f314cf8c1c540e1d05989080e"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#a57b3ac5f314cf8c1c540e1d05989080e">Louvre::LSeat::pointer</a></div><div class="ttdeci">LPointer * pointer() const</div><div class="ttdoc">Access to pointer events.</div><div class="ttdef"><b>Definition:</b> LSeat.cpp:122</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_seat_html_aedd1827579c590a4a37c04a52662d6b5"><div class="ttname"><a href="class_louvre_1_1_l_seat.html#aedd1827579c590a4a37c04a52662d6b5">Louvre::LSeat::dndManager</a></div><div class="ttdeci">LDNDManager * dndManager() const</div><div class="ttdoc">Access to the drag &amp; drop session manager.</div><div class="ttdef"><b>Definition:</b> LSeat.cpp:137</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_surface_html_ad9c27f2d106edb222bc33c4bfc384f58"><div class="ttname"><a href="class_louvre_1_1_l_surface.html#ad9c27f2d106edb222bc33c4bfc384f58">Louvre::LSurface::raise</a></div><div class="ttdeci">void raise()</div><div class="ttdoc">Moves a surface to the top of the compositor's surfaces list.</div><div class="ttdef"><b>Definition:</b> LSurface.cpp:417</div></div>
<div class="ttc" id="anamespace_louvre_html_a968dc093fddc639543f84e482dc539e6"><div class="ttname"><a href="namespace_louvre.html#a968dc093fddc639543f84e482dc539e6">Louvre::LRect</a></div><div class="ttdeci">LRectTemplate&lt; Int32, Float32 &gt; LRect</div><div class="ttdoc">4D vector of 32 bits integers</div><div class="ttdef"><b>Definition:</b> LNamespaces.h:252</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="ad4dc5e1f724869e9523ce872afd56a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4dc5e1f724869e9523ce872afd56a1a">&#9670;&nbsp;</a></span>resizeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void resizeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a" title="Resize Event.">resizeGL()</a> event is invoked by the library when the output scale or mode changes.<br  />
Override this method to readjust your graphical interfaces.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing any painting operations here, as they won't be visible on the screen. Instead, perform painting tasks in the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<p>The default implementation simply schedules a new rendering frame with <a class="el" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f" title="Schedule the next rendering frame.">repaint()</a>.</p>
<h4><a class="anchor" id="autotoc_md19"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">LOutput::resizeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f">repaint</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ac827b978aa122f136a14c198687ad80f"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f">Louvre::LOutput::repaint</a></div><div class="ttdeci">void repaint()</div><div class="ttdoc">Schedule the next rendering frame.</div><div class="ttdef"><b>Definition:</b> LOutput.cpp:278</div></div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_ad4dc5e1f724869e9523ce872afd56a1a"><div class="ttname"><a href="class_louvre_1_1_l_output.html#ad4dc5e1f724869e9523ce872afd56a1a">Louvre::LOutput::resizeGL</a></div><div class="ttdeci">virtual void resizeGL()</div><div class="ttdoc">Resize Event.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="aa15f67e7da7f9351890b2c6258ee9225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15f67e7da7f9351890b2c6258ee9225">&#9670;&nbsp;</a></span>moveGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void moveGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move Event. </p>
<p>This event is triggered when the output's position changes, such as when the <a class="el" href="class_louvre_1_1_l_output.html#abd9b75c5594e4fa1e61839aa211f4740" title="Set the position of the output.">setPos()</a> method is called.<br  />
Override this method to readjust your graphical interfaces.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing any painting operations here, as they won't be visible on the screen. Instead, perform painting tasks in the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="autotoc_md20"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">LOutput::moveGL</a>()</div>
<div class="line">{</div>
<div class="line">    <a class="code" href="class_louvre_1_1_l_output.html#ac827b978aa122f136a14c198687ad80f">repaint</a>();</div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_aa15f67e7da7f9351890b2c6258ee9225"><div class="ttname"><a href="class_louvre_1_1_l_output.html#aa15f67e7da7f9351890b2c6258ee9225">Louvre::LOutput::moveGL</a></div><div class="ttdeci">virtual void moveGL()</div><div class="ttdoc">Move Event.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a454d002ee90273a44dfb59a30246129e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a454d002ee90273a44dfb59a30246129e">&#9670;&nbsp;</a></span>uninitializeGL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void uninitializeGL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Uninitialize Event. </p>
<p>The <a class="el" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e" title="Uninitialize Event.">uninitializeGL()</a> event is invoked by the library after the output is removed from the compositor with <a class="el" href="class_louvre_1_1_l_compositor.html#aa6d9794dfb7cb513f834cf503591b864" title="Uninitializes the specified output.">LCompositor::removeOutput()</a>.<br  />
This event is also automatically invoked when the output is unplugged, check the <a class="el" href="class_louvre_1_1_l_seat.html#aff161f8b1d3c715362778773b4b612c6" title="Disconnected output.">LSeat::outputUnplugged()</a> event.<br  />
Override this method to free your shaders, programs, textures, etc.</p>
<dl class="section note"><dt>Note</dt><dd>Avoid performing any painting operations here, as they won't be visible on the screen. Instead, perform painting tasks in the <a class="el" href="class_louvre_1_1_l_output.html#a0569e991ee4c6e4242578aca6d999741" title="Paint Event.">paintGL()</a> event.</dd></dl>
<h4><a class="anchor" id="autotoc_md21"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">LOutput::uninitializeGL</a>()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a454d002ee90273a44dfb59a30246129e"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a454d002ee90273a44dfb59a30246129e">Louvre::LOutput::uninitializeGL</a></div><div class="ttdeci">virtual void uninitializeGL()</div><div class="ttdoc">Uninitialize Event.</div></div>
</div><!-- fragment -->
</div>
</div>
<a id="a386f3d06f6c9f2d60e66c6da5bf3dd1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a386f3d06f6c9f2d60e66c6da5bf3dd1a">&#9670;&nbsp;</a></span>setGammaRequest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void setGammaRequest </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_louvre_1_1_l_client.html">LClient</a> *&#160;</td>
          <td class="paramname"><em>client</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_louvre_1_1_l_gamma_table.html">LGammaTable</a> *&#160;</td>
          <td class="paramname"><em>gamma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set gamma table request. </p>
<p>Clients using the <a href="https://wayland.app/protocols/wlr-gamma-control-unstable-v1#zwlr_gamma_control_manager_v1">wlr gamma control</a> protocol can request to set the gamma table for an output.</p>
<dl class="section warning"><dt>Warning</dt><dd>For security reasons, it is advisable to permit only authorized clients to perform such actions. The default implementation ignores all requests, and the mechanism to identify an authorized client is left to the developer's discretion.</dd></dl>
<p>The gamma table (when is not <code>nullptr</code>) always have a size equal to <a class="el" href="class_louvre_1_1_l_output.html#a3526adc24e3f23a42cbf50a625569cfd" title="Gets the size of the gamma table.">gammaSize()</a>, hence, it is not necessary to validate that.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">client</td><td>Pointer to the client making the request. </td></tr>
    <tr><td class="paramname">gamma</td><td>Pointer to the <a class="el" href="class_louvre_1_1_l_gamma_table.html" title="Gamma correction table for outputs.">LGammaTable</a> object containing the requested gamma table or <code>nullptr</code> to restore the default table.</td></tr>
  </table>
  </dd>
</dl>
<h4><a class="anchor" id="autotoc_md22"></a>
Default Implementation</h4>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">LOutput::setGammaRequest</a>(LClient *client, <span class="keyword">const</span> LGammaTable *gamma)</div>
<div class="line">{</div>
<div class="line">    L_UNUSED(client)</div>
<div class="line">    L_UNUSED(gamma)</div>
<div class="line"> </div>
<div class="line">    <span class="comment">/* No default implementation */</span></div>
<div class="line">}</div>
<div class="ttc" id="aclass_louvre_1_1_l_output_html_a386f3d06f6c9f2d60e66c6da5bf3dd1a"><div class="ttname"><a href="class_louvre_1_1_l_output.html#a386f3d06f6c9f2d60e66c6da5bf3dd1a">Louvre::LOutput::setGammaRequest</a></div><div class="ttdeci">virtual void setGammaRequest(LClient *client, const LGammaTable *gamma)</div><div class="ttdoc">Set gamma table request.</div></div>
</div><!-- fragment -->
</div>
</div>
</div><!-- contents -->
<script>
    var menu = false;
    var burger, nav;
    function resp()
    {
        if (window.innerWidth < 768)
        {
            burger.hidden = false;
            nav.hidden = true;
        }
        else
        {
            burger.hidden = true;
            nav.hidden = false;
        }
        menu = false;
    }
    function toggleMenu()
    {
        nav.hidden = menu;
        menu = !menu;
    }
    window.onload = function()
    {
        // Get all <a> tags with the "el" class
        var elLinks = document.querySelectorAll('a.el');
        // Loop through the matched elements
        elLinks.forEach(function(link) 
        {
            // Replace "Louvre::" with an empty string in the text content
            link.textContent = link.textContent.replace(/Louvre::/g, '');
        });
        nav = document.getElementById('main-nav');
        burger = document.createElement('div');
        burger.style.position = 'absolute';
        burger.style.top = '14px';
        burger.style.right = burger.style.top;
        burger.innerHTML = '<svg onclick="toggleMenu()" height="32px" viewBox="0 0 448 512"><path d="M0 96C0 78.3 14.3 64 32 64H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32C14.3 128 0 113.7 0 96zM0 256c0-17.7 14.3-32 32-32H416c17.7 0 32 14.3 32 32s-14.3 32-32 32H32c-17.7 0-32-14.3-32-32zM448 416c0 17.7-14.3 32-32 32H32c-17.7 0-32-14.3-32-32s14.3-32 32-32H416c17.7 0 32 14.3 32 32z"/></svg>';
        document.getElementById('top').appendChild(burger);
        resp();
    };
    window.onresize = function()
    {
        resp();
    };
</script>
<div id="nav-path" class="navpath">
    <ul>
        <li class="footer">Project developed by <a href="https://github.com/CuarzoSoftware"><img class="footer" src="https://avatars.githubusercontent.com/u/29326763?s=200&v=4" style="margin-left:2px;position:relative;top:-1px;width:12px;height:12px" alt="cuarzo"/> Cuarzo Software</a></li>
    </ul>
</div>